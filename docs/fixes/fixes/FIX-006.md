# Fix Report: FIX-006 — Fix 06-matching-ui findings

**Date:** 2026-02-15T12:27:06Z
**Verification:** pnpm lint + pnpm test passed

---

## Findings addressed

### [CRITICAL] Finding #1: `useEffect` dependency can crash on non-array/nullable `sets` entries

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 14-25, 44-86

**Description:** `flattenSetlist()` explicitly tolerates malformed `setlist.sets` items by skipping non-arrays (`if (!Array.isArray(set)) continue;`). However, the `useEffect` dependency array assumes every `setlist.sets` item has a `.length` property and is safe to access:

**Fix applied:** Addressed (verification passed).

---

### [HIGH] Finding #2: Suggestion fetch effect dependencies are insufficient (stale suggestions + stale UI state)

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 44-86

**Description:** The suggestions `useEffect` only re-runs when `setlist.id` or the comma-joined list of `set` lengths changes. It does not account for changes to:

**Fix applied:** Addressed (verification passed).

---

### [HIGH] Finding #3: UI renders from derived state snapshots, not the `setlist` prop (enables desync)

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 33-37, 44-53, 140-146

**Description:** The displayed setlist content (song name/artist) comes from `matches` state (`row.setlistEntry`) rather than directly from the `setlist` prop. Since `matches` is initialized from props and only conditionally re-synced by the effect, any missed dependency update (or partial update) leaves the rendered list potentially out of sync with the actual `setlist` prop.

**Fix applied:** Addressed (verification passed).

---

### [HIGH] Finding #4: Unstable list keys (`key={index}`) can mis-associate rows and user selections

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 131-139

**Description:** The main list uses array index keys. If rows are inserted/removed/reordered (including via setlist refresh or re-flattening), React may reuse DOM/state in a way that visually attaches the wrong match/search UI to the wrong setlist entry.

**Fix applied:** Addressed (verification passed).

---

### [HIGH] Finding #5: Suggestion-fetch failures are silently treated as “No match” (no error surface)

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 55-77, 148-157

**Description:** All failures during suggestion fetching (including MusicKit not loaded, dev token fetch failing, Apple API errors) are caught and converted into `appleTrack: null`, with no user-visible indication that the suggestion system failed.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #6: Suggestions are fetched sequentially with a global loading indicator (slow + unclear progress)

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 55-80, 125-129

**Description:** Suggestions are fetched in a `for` loop with `await` per entry, making total time scale linearly with setlist size. The UI shows a single “Fetching suggestions…” message until the entire loop completes.

**Fix applied:** Addressed (verification passed).

---

### [HIGH] Finding #7: Manual search results can display under the wrong row (in-flight search not tied to index)

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 100-114, 160-167, 181-226

**Description:** Manual search uses global `searchResults`/`searching` state that is not associated with the specific row being searched. If the user changes `searchingIndex` while a search is in flight (by clicking “Change” on a different row), the in-flight promise resolves and writes results into the global `searchResults`, which will then render under whichever row is currently open.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #8: Manual search requests can race (no cancellation / last-resolve-wins)

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 100-114

**Description:** `runSearch()` does not cancel prior requests or guard against out-of-order resolution. Multiple searches (rapid clicks, Enter presses, or searches with changing queries) can resolve in an unexpected order and overwrite `searchResults` with stale data.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #9: Manual search has no explicit “no results” or “error” UI state

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 106-113, 204-226

**Description:** When search returns zero results or throws, the UI just shows nothing (empty area). There is no user-visible distinction between:

**Fix applied:** Addressed (verification passed).

---

### [LOW] Finding #10: Search input is placeholder-only (missing accessible label)

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 183-195

**Description:** The search input has no associated `<label>` and relies on placeholder text. This reduces accessibility and can make the control ambiguous for assistive technologies.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #11: Manual-search UI state is not reset when the setlist changes

**File:** `apps/web/src/features/matching/MatchingView.tsx`

**Lines:** 38-43, 44-53, 88-98

**Description:** On setlist changes, the effect reinitializes `matches` but does not reset `searchingIndex`, `searchQuery`, `searchResults`, or `searching`. This can leave:

**Fix applied:** Addressed (verification passed).

---

### [HIGH] Finding #12: `searchCatalog` cache key ignores `limit` and `storefront` (truncates manual search + cross-region staleness)

**File:** `apps/web/src/lib/musickit.ts`

**Lines:** 149-203

**Description:** `searchCatalog(term, limit)` caches results only by `term`. It does not include `limit` or the resolved `storefront` in the cache key:

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #13: `waitForMusicKit()` leaves a live timeout even after resolving (timer accumulation)

**File:** `apps/web/src/lib/musickit.ts`

**Lines:** 73-93

**Description:** When `window.MusicKit` becomes available, the interval is cleared and the promise resolves, but the `setTimeout` is never cleared. The timeout will still fire later (up to 10s), performing work and calling `reject` after the promise already resolved.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #14: `initMusicKit()` / `fetchDeveloperToken()` have no in-flight guard (concurrent calls can race)

**File:** `apps/web/src/lib/musickit.ts`

**Lines:** 53-70, 96-122

**Description:** Both token fetching and MusicKit configuration rely on module-level caches (`cachedToken`, `configuredInstance`) but do not gate concurrent calls:

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #15: Connect flow allows concurrent authorization attempts (re-entrancy)

**File:** `apps/web/src/features/matching/ConnectAppleMusic.tsx`

**Lines:** 21-40, 45-57, 71-77

**Description:** `handleAuthorize()` does not guard against re-entrancy. While the main button is disabled via `disabled={loading}`, there is a window where the handler can be triggered multiple times (double-click before React state applies), and the error “Try again” button does not check `loading` at all (it relies on `setError(null)` hiding the alert after state updates).

**Fix applied:** Addressed (verification passed).

---

### [LOW] Finding #16: Error classification is fragile and can surface raw internal messages

**File:** `apps/web/src/features/matching/ConnectAppleMusic.tsx`

**Lines:** 29-37

**Description:** The code matches substrings in the error message (`includes("cancel")`, `includes("denied")`, etc.) in a case-sensitive way and otherwise displays the raw error message. This is brittle and may lead to inconsistent user-facing messaging depending on the exact casing/wording of underlying errors.

**Fix applied:** Addressed (verification passed).

---


*Report generated by ralph-fix.sh after verification passed.*
