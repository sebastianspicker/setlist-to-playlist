# Fix Report: FIX-003 — Fix 03-setlist-proxy findings

**Date:** 2026-02-15T12:27:06Z
**Verification:** pnpm lint + pnpm test passed

---

## Findings addressed

### [HIGH] Finding #1: Public proxy can be abused to drain `SETLISTFM_API_KEY` quota (CORS is not access control)

**File:** `apps/web/src/app/api/setlist/proxy/route.ts`

**Lines:** 11-44

**Description:** This is a public, unauthenticated GET endpoint that triggers server-side calls to setlist.fm using the server’s `SETLISTFM_API_KEY` (via `handleSetlistProxy`). The only “restriction” visible here is CORS response headers, but CORS only affects whether browser JavaScript can read the response. Any non-browser client (curl, bots, server-to-server) can call this endpoint directly and force upstream requests, consuming rate limits/quota and potentially causing service degradation.

**Fix applied:** Addressed (verification passed).

---

### [HIGH] Finding #2: Upstream fetch has no timeout/abort; requests can hang and tie up server resources

**File:** `apps/api/src/lib/setlistfm.ts`

**Lines:** 92-125

**Description:** `fetchSetlistFromApi` calls `fetch()` without any timeout/abort. Network stalls (DNS issues, upstream hangs, partial connectivity) can lead to long-running requests. Because this runs in an API route path, hung upstream calls can accumulate under load, consuming runtime resources and causing cascading latency/failures.

**Fix applied:** Addressed (verification passed).

---

### [HIGH] Finding #3: “Cache eviction threshold” does not cap cache size; memory can grow unbounded within TTL window

**File:** `apps/api/src/lib/setlistfm.ts`

**Lines:** 38-67

**Description:** The cache only evicts *expired* entries when `cache.size > CACHE_EVICT_THRESHOLD`. If an attacker (or heavy usage) requests many unique setlist IDs within the 1-hour TTL, none expire, so `evictExpired()` deletes nothing and the `Map` continues growing without bound. The threshold reduces eviction frequency but does not enforce a maximum size.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #4: Host validation contradicts comment; `includes("setlist.fm")` accepts lookalike domains

**File:** `apps/api/src/lib/setlistfm.ts`

**Lines:** 15-16

**Description:** The comment says “only accept URLs whose host is setlist.fm”, but the implementation uses substring matching on hostname. This accepts hosts like `evilsetlist.fm` or `setlist.fm.evil.com`, which are not setlist.fm.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #5: Setlist ID validation is inconsistent and overly permissive (e.g., accepts all-hyphen “IDs”)

**File:** `apps/api/src/lib/setlistfm.ts`

**Lines:** 18-35

**Description:** The parser uses multiple, inconsistent acceptance rules:

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #6: Upstream error message forwarding can leak raw upstream content (JSON/HTML) to clients

**File:** `apps/api/src/lib/setlistfm.ts`

**Lines:** 111-117

**Description:** On non-OK responses, the code reads the entire response body as text and tries to parse JSON. If parsing succeeds but the JSON does not have a top-level `message`, it falls back to `text`, which is the full response payload. That payload then becomes `result.message` and is returned to clients (truncated later, but still raw upstream content).

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #7: Proxy forwards upstream error strings to clients with minimal sanitization

**File:** `apps/api/src/routes/setlist/proxy.ts`

**Lines:** 38-46

**Description:** `handleSetlistProxy` truncates error strings to 500 chars but otherwise forwards upstream-derived messages. Combined with the upstream behavior in `fetchSetlistFromApi`, this means end users can receive arbitrary upstream text/JSON/HTML fragments.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #8: No response-shape validation; `unknown` is passed through end-to-end

**File:** `apps/api/src/lib/setlistfm.ts`

**Lines:** 72-75, 96-109

**Description:** Successful responses are typed as `unknown`, cached as `unknown`, and returned as-is. No runtime validation ensures the payload actually matches the expected setlist.fm “setlist” shape. If setlist.fm returns a partial payload, an error payload with 200 status, or an unexpected structure, downstream code may break or show incorrect data.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #9: 429 handling is simplistic; no use of server guidance headers and no global throttling

**File:** `apps/api/src/lib/setlistfm.ts`

**Lines:** 69-133

**Description:** The retry loop uses a fixed backoff schedule (1s, 2s) with a small retry count and does not consider any response headers that might guide retry timing (if present). It also retries per-request without any shared throttling, so concurrent bursts can repeatedly hit 429 and multiply load.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #10: Cache can serve stale setlist data despite API being “current version”; no cache-bypass mechanism

**File:** `apps/api/src/lib/setlistfm.ts`

**Lines:** 38-48, 80-82

**Description:** The implementation caches setlist responses for 1 hour and always serves cached results when present. The setlist.fm API endpoint explicitly returns the “current version” of a setlist (which can change if edited), but this proxy can serve up to 1 hour of stale data with no bypass/refresh path.

**Fix applied:** Addressed (verification passed).

---

### [LOW] Finding #11: Minor code slop / redundancy in route handler status assignment

**File:** `apps/web/src/app/api/setlist/proxy/route.ts`

**Lines:** 35-36

**Description:** The status computation is redundant and does not meaningfully branch; both sides return `result.status`. This looks like leftover code and adds noise to a security-sensitive route.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #12: Dynamic `Access-Control-Allow-Origin` without `Vary: Origin` can enable cache confusion

**File:** `apps/web/src/lib/cors.ts`

**Lines:** 20-27

**Description:** When CORS is enabled, `Access-Control-Allow-Origin` is set dynamically based on environment/request origin. The response headers do not include `Vary: Origin`. If an intermediary cache/CDN ever caches these GET responses, it could incorrectly serve a response with a previously set `Access-Control-Allow-Origin` value to a different requesting origin.

**Fix applied:** Addressed (verification passed).

---


*Report generated by ralph-fix.sh after verification passed.*
