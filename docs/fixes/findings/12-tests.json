{
  "auditTitle": "Tests Deep Audit",
  "auditDate": "2026-02-15T07:57:10Z",
  "filesExamined": 22,
  "totalFindings": 17,
  "summary": {
    "critical": 0,
    "high": 9,
    "medium": 5,
    "low": 3
  },
  "findings": [
    {
      "severity": "LOW",
      "number": 1,
      "title": "`apps/web` test suite is placeholder-only (no coverage of critical web paths)",
      "file": "apps/web/tests/example.test.ts",
      "lines": "1-6",
      "category": "slop",
      "description": "The only in-scope `apps/web` test is a generic arithmetic assertion and does not import or exercise any app code. This means there is effectively **no test coverage** for web critical paths (MusicKit flows, setlist import/matching/export UI, Next.js route handlers, CORS helper, API URL building).",
      "code": "import { describe, it, expect } from 'vitest';\n\ndescribe('web app', () => {\n  it('placeholder test', () => {\n    expect(1 + 1).toBe(2);\n  });\n});",
      "whyThisMatters": "Regressions in the web app’s main flows can ship undetected because the test suite does not execute any of the app’s logic."
    },
    {
      "severity": "LOW",
      "number": 2,
      "title": "`apps/api` “health” test is minimal and does not validate important behavior",
      "file": "apps/api/tests/example.test.ts",
      "lines": "1-9",
      "category": "slop",
      "description": "This is a basic smoke test for `handleHealth()` that only checks `timestamp` is defined (not shape/format) and doesn’t validate any time-related invariants.",
      "code": "it('health returns ok', () => {\n  const res = handleHealth();\n  expect(res.status).toBe('ok');\n  expect(res.timestamp).toBeDefined();\n});",
      "whyThisMatters": "If `timestamp` becomes an invalid value (wrong format, non-ISO, empty string), this test would still pass, allowing API consumers to break."
    },
    {
      "severity": "LOW",
      "number": 3,
      "title": "Unused `beforeEach` import in setlist proxy tests",
      "file": "apps/api/tests/setlist-proxy.test.ts",
      "lines": "1",
      "category": "slop",
      "description": "`beforeEach` is imported but never used, indicating test-code hygiene issues and increasing the chance of stale or incomplete setup patterns.",
      "code": "import { describe, it, expect, beforeEach, afterEach, vi } from \"vitest\";",
      "whyThisMatters": "Test suites with small hygiene issues tend to accumulate hidden state problems and misleading coverage over time."
    },
    {
      "severity": "HIGH",
      "number": 4,
      "title": "`vi.stubGlobal(\"fetch\", ...)` is not reliably undone; potential cross-test contamination",
      "file": "apps/api/tests/setlist-proxy.test.ts",
      "lines": "36-39, 63-71, 83-93, 102-112",
      "category": "will-break",
      "description": "The suite stubs `fetch` globally via `vi.stubGlobal(\"fetch\", ...)` but only calls `vi.restoreAllMocks()` in `afterEach`. In Vitest, restoring mocks does not necessarily revert stubbed globals, which can make other tests order-dependent (especially if additional suites rely on real `fetch` behavior or different stubs).",
      "code": "afterEach(() => {\n  process.env.SETLISTFM_API_KEY = origKey;\n  vi.restoreAllMocks();\n});\n\n// ...\nvi.stubGlobal(\"fetch\", vi.fn(() => Promise.resolve({ ok: true, json: () => Promise.resolve(mockSetlist) } as Response)));\n\n// ...\nvi.stubGlobal(\"fetch\", vi.fn(() => Promise.resolve({ ok: false, status: 404, text: () => Promise.resolve(\"Not found\"), statusText: \"Not Found\" } as Response)));\n\n// ...\nvi.stubGlobal(\"fetch\", vi.fn(() => Promise.resolve({ ok: false, status: 429, text: () => Promise.resolve(\"Too Many Requests\"), statusText: \"Too Many Requests\" } as Response)));",
      "whyThisMatters": "A single leaked global stub can cause unrelated tests to pass/fail incorrectly, masking real regressions or creating flaky CI."
    },
    {
      "severity": "MEDIUM",
      "number": 5,
      "title": "429 retry test likely incurs real backoff waits and does not prove retries occurred",
      "file": "apps/api/tests/setlist-proxy.test.ts",
      "lines": "100-118",
      "category": "will-break",
      "description": "The test name claims “after retries”, but it does not assert call counts or timing behavior, and the underlying implementation performs real `setTimeout` backoff for 429s. This can make the test suite slow and still pass even if retry logic is removed or altered (as long as the final 429 message remains).",
      "code": "it(\"returns rate-limit message on 429 after retries\", async () => {\n  process.env.SETLISTFM_API_KEY = \"test-key\";\n  vi.stubGlobal(\"fetch\", vi.fn(() => Promise.resolve({ ok: false, status: 429, text: () => Promise.resolve(\"Too Many Requests\"), statusText: \"Too Many Requests\" } as Response)));\n\n  const result = await handleSetlistProxy(\"63de4614\");\n  expect(\"error\" in result).toBe(true);\n  expect(\"error\" in result && result.status).toBe(429);\n  expect(\"error\" in result && result.error).toMatch(/rate limit/i);\n});",
      "whyThisMatters": "Slow and non-specific tests increase CI time and can miss regressions in retry/backoff behavior."
    },
    {
      "severity": "HIGH",
      "number": 6,
      "title": "Proxy tests do not assert outgoing request URL/headers; mock does not validate critical API-key handling",
      "file": "apps/api/tests/setlist-proxy.test.ts",
      "lines": "55-79",
      "category": "will-break",
      "description": "The successful proxy test stubs `fetch` but never asserts it was called with:\n- the correct setlist.fm endpoint path (`/setlist/{id}`)\n- `x-api-key` header usage (vs accidental query param leakage)\n- correct `Accept` header\n- correct `encodeURIComponent` behavior for IDs\n\nAs written, the test would still pass if the implementation calls the wrong URL, omits headers, or accidentally leaks the API key into the URL (so long as the stub returns `ok: true`).",
      "code": "vi.stubGlobal(\n  \"fetch\",\n  vi.fn(() =>\n    Promise.resolve({\n      ok: true,\n      json: () => Promise.resolve(mockSetlist),\n    } as Response)\n  )\n);\n\nconst result = await handleSetlistProxy(\"63de4613\");\nexpect(\"body\" in result).toBe(true);\nif (\"body\" in result) {\n  expect(result.body).toEqual(mockSetlist);\n  expect(result.status).toBe(200);\n}",
      "whyThisMatters": "The proxy’s core safety property is “API key is server-side only and sent via headers”; missing assertions here can allow silent regressions that break functionality or increase leakage risk."
    },
    {
      "severity": "HIGH",
      "number": 7,
      "title": "No tests cover `fetchSetlistFromApi()` critical branches (cache, invalid JSON, JSON error parsing, retry/backoff)",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "38-140",
      "category": "will-break",
      "description": "`fetchSetlistFromApi()` contains multiple critical behaviors (cache TTL, eviction threshold logic, 429 retry/backoff, parsing error bodies that may be JSON, and a 502 path for non-JSON success responses). None of these are directly tested in-scope; current coverage only calls `handleSetlistProxy()` and checks final outputs for a small set of statuses.",
      "code": "const cache = new Map<string, { body: unknown; expires: number }>();\n\nexport async function fetchSetlistFromApi(setlistId: string, apiKey: string): Promise<FetchSetlistResult> {\n  const cached = getCached(setlistId);\n  if (cached !== null) return { ok: true, body: cached };\n\n  // ...\n  for (let attempt = 0; attempt <= MAX_RETRIES_429; attempt++) {\n    const res = await fetch(url, { headers });\n\n    if (res.ok) {\n      let body: unknown;\n      try {\n        body = (await res.json()) as unknown;\n      } catch {\n        return { ok: false, status: 502, message: \"Invalid response from setlist.fm (non-JSON body).\" };\n      }\n      setCached(setlistId, body);\n      return { ok: true, body };\n    }\n\n    const text = await res.text();\n    try {\n      const json = JSON.parse(text) as { message?: string };\n      lastMessage = json.message ?? (text || res.statusText);\n    } catch {\n      lastMessage = text || res.statusText;\n    }\n\n    if (res.status === 429 && attempt < MAX_RETRIES_429) {\n      await new Promise((r) => setTimeout(r, BACKOFF_MS * (attempt + 1)));\n      continue;\n    }\n    break;\n  }\n  // ...\n}",
      "whyThisMatters": "Most production failures for the setlist proxy will occur in these branches (rate limits, malformed upstream payloads, caching behavior, error message parsing). Untested branches are prime regression points."
    },
    {
      "severity": "HIGH",
      "number": 8,
      "title": "Missing tests for `handleSetlistProxy()` status mapping and error truncation behaviors",
      "file": "apps/api/src/routes/setlist/proxy.ts",
      "lines": "36-46",
      "category": "will-break",
      "description": "The route maps upstream status codes to output statuses (notably mapping `>=500` to `503`) and truncates overly-long error messages to 500 chars. Current tests cover `503` (missing key), `400` (invalid input), `200` (ok), `404`, `429` — but do not cover:\n- upstream `500/502` mapping behavior\n- truncation behavior for long messages\n- behavior when `result.message` is empty (fallback message formatting)",
      "code": "const status =\n  result.status === 404 ? 404 : result.status >= 500 ? 503 : result.status;\nconst MAX_ERROR_MESSAGE_LENGTH = 500;\nconst message =\n  typeof result.message === \"string\" && result.message.length > MAX_ERROR_MESSAGE_LENGTH\n    ? result.message.slice(0, MAX_ERROR_MESSAGE_LENGTH) + \"…\"\n    : result.message;\nreturn { error: message, status };",
      "whyThisMatters": "These behaviors directly affect client UX and resilience during upstream failures; regressions can lead to misleading status codes or oversized error payloads."
    },
    {
      "severity": "HIGH",
      "number": 9,
      "title": "`parseSetlistIdFromInput()` tests miss security-relevant URL host edge cases and fallback branches",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "8-29",
      "category": "will-break",
      "description": "The parser has complex branching: it treats inputs containing `\"setlist.fm\"` as URL-like, constructs a URL when scheme is missing, and checks `url.hostname.toLowerCase().includes(\"setlist.fm\")`. In-scope tests validate only a canonical setlist.fm URL and a few ID formats, but do not cover:\n- host confusion cases (e.g. subdomains or hostnames containing `setlist.fm` as a substring)\n- scheme-less inputs that include `setlist.fm` (triggering the URL branch)\n- fallback extraction logic for last path segments (lines 21-26)\n- cases where `.match(/-([a-f0-9]{4,12})\\.html$/i)` fails but fallback succeeds",
      "code": "if (trimmed.startsWith(\"http://\") || trimmed.startsWith(\"https://\") || trimmed.includes(\"setlist.fm\")) {\n  try {\n    const url = new URL(trimmed.startsWith(\"http\") ? trimmed : `https://${trimmed}`);\n    if (!url.hostname.toLowerCase().includes(\"setlist.fm\")) return null;\n    const match = url.pathname.match(/-([a-f0-9]{4,12})\\.html$/i);\n    if (match) return match[1];\n    const segment = url.pathname.split(\"/\").filter(Boolean).pop() ?? \"\";\n    const withoutHtml = segment.replace(/\\.html$/i, \"\");\n    const idPart = withoutHtml.split(\"-\").pop();\n    if (idPart && /^[a-f0-9]{4,12}$/i.test(idPart)) return idPart;\n    if (withoutHtml && /^[a-f0-9-]+$/i.test(withoutHtml)) return withoutHtml;\n  } catch {\n    return null;\n  }\n  return null;\n}",
      "whyThisMatters": "Parsing is a primary input-validation boundary for the proxy. Untested host/URL edge cases can allow regressions that accept malformed inputs or reject valid ones."
    },
    {
      "severity": "HIGH",
      "number": 10,
      "title": "Dev token tests only validate “JWT-like string”; no coverage of required JWT claims/header fields or TTL",
      "file": "apps/api/tests/dev-token.test.ts",
      "lines": "8-10, 35-46",
      "category": "will-break",
      "description": "The success case checks only that the token is a non-empty string matching a 3-segment regex. It does **not** validate:\n- protected header fields (e.g. `alg`, `kid`)\n- issuer (`iss`)\n- presence/shape of `iat` and `exp`\n- that `exp` is about 1 hour after issuance (as implemented)\n- that PEM newline normalization works for escaped `\\\\n` variants",
      "code": "/** JWT shape: three base64url segments separated by dots */\nconst JWT_REGEX = /^[\\w-]+\\.[\\w-]+\\.[\\w-]+$/;\n\nconst result = await handleDevToken();\nexpect(\"token\" in result).toBe(true);\nif (\"token\" in result) {\n  expect(result.token).toBeTypeOf(\"string\");\n  expect(result.token.length).toBeGreaterThan(0);\n  expect(result.token).toMatch(JWT_REGEX);\n}",
      "whyThisMatters": "A token can be “JWT-shaped” but still unusable for MusicKit (wrong `alg`, missing `kid`, wrong `iss`, bad `exp`). These would be production-breaking regressions not caught by tests."
    },
    {
      "severity": "MEDIUM",
      "number": 11,
      "title": "`handleDevToken()` missing coverage for whitespace-only env vars and signing failure branch",
      "file": "apps/api/src/routes/apple/dev-token.ts",
      "lines": "11-29",
      "category": "will-break",
      "description": "`handleDevToken()` explicitly trims env vars and returns a generic `{ error }` on signing failure. In-scope tests cover only:\n- missing env (fully deleted)\n- happy-path signing with a fixture key\n\nThey do not cover:\n- env vars present but whitespace-only (trim-to-empty)\n- `signDeveloperToken` throwing (catch branch)",
      "code": "const teamId = process.env.APPLE_TEAM_ID?.trim();\nconst keyId = process.env.APPLE_KEY_ID?.trim();\nconst privateKey = process.env.APPLE_PRIVATE_KEY?.trim();\n\nif (!teamId || !keyId || !privateKey) {\n  return { error: \"Missing Apple credentials in environment\" };\n}\n\ntry {\n  const token = await signDeveloperToken({ teamId, keyId, privateKeyPem: privateKey });\n  return { token };\n} catch {\n  return { error: \"Token signing failed. Check server configuration and logs.\" };\n}",
      "whyThisMatters": "These are the two most common operational failure modes (misconfigured env and invalid key material). Without tests, regressions can change behavior or error messaging unexpectedly."
    },
    {
      "severity": "HIGH",
      "number": 12,
      "title": "No tests for CORS policy helper (`getAllowOrigin`, OPTIONS preflight headers)",
      "file": "apps/web/src/lib/cors.ts",
      "lines": "8-43",
      "category": "will-break",
      "description": "CORS behavior is a security boundary for routes serving tokens and proxying setlist.fm. There are no in-scope tests that exercise:\n- `ALLOWED_ORIGIN` trimming / first-origin selection\n- trailing-slash normalization\n- localhost-only behavior when `ALLOWED_ORIGIN` is unset\n- that OPTIONS responses include required preflight headers",
      "code": "export function getAllowOrigin(origin: string | null): string | null {\n  const configured = (process.env.ALLOWED_ORIGIN ?? \"\").trim();\n  const isLocalOrigin =\n    origin && (origin.startsWith(\"http://localhost\") || origin.startsWith(\"http://127.0.0.1\"));\n  if (configured) {\n    const single = configured.split(\",\")[0].trim().replace(/\\/$/, \"\");\n    return single || (isLocalOrigin ? origin : null);\n  }\n  return isLocalOrigin ? origin : null;\n}\n\nexport function corsHeadersForOptions(request: NextRequest): HeadersInit {\n  const origin = request.headers.get(\"origin\");\n  const allowOrigin = getAllowOrigin(origin);\n  const headers: Record<string, string> = {};\n  if (allowOrigin) {\n    headers[\"Access-Control-Allow-Origin\"] = allowOrigin;\n    headers[\"Access-Control-Allow-Methods\"] = \"GET, OPTIONS\";\n    headers[\"Access-Control-Allow-Headers\"] = \"Content-Type\";\n  }\n  return headers;\n}",
      "whyThisMatters": "A small regression in CORS logic can either break legitimate clients (too strict) or widen token/proxy access unexpectedly (too permissive). With no tests, these changes are likely to slip through."
    },
    {
      "severity": "HIGH",
      "number": 13,
      "title": "No tests for Next.js route handlers (dev-token, setlist proxy, health), including CORS + query validation behavior",
      "file": "apps/web/src/app/api/setlist/proxy/route.ts",
      "lines": "5-43",
      "category": "will-break",
      "description": "There are no in-scope tests validating route-handler behavior for:\n- required query param (`id` or `url`) handling\n- max input length enforcement\n- response status selection\n- CORS headers on GET and OPTIONS\n- try/catch fallback error shape\n\nThis is especially critical because these handlers are the externally reachable HTTP boundary.",
      "code": "const MAX_SETLIST_INPUT_LENGTH = 2000;\n\nexport async function OPTIONS(request: NextRequest) {\n  return new Response(null, { status: 204, headers: corsHeadersForOptions(request) });\n}\n\nexport async function GET(request: NextRequest) {\n  const id = request.nextUrl.searchParams.get(\"id\") ?? request.nextUrl.searchParams.get(\"url\") ?? \"\";\n  if (!id) {\n    return new Response(JSON.stringify({ error: \"Missing id or url query parameter\" }), {\n      status: 400,\n      headers: corsHeaders(request),\n    });\n  }\n  if (id.length > MAX_SETLIST_INPUT_LENGTH) {\n    return new Response(JSON.stringify({ error: \"Input too long. Use setlist ID or a shorter setlist.fm URL (max 2000 characters).\" }), {\n      status: 400,\n      headers: corsHeaders(request),\n    });\n  }\n\n  try {\n    const result = await handleSetlistProxy(id);\n    const status = \"error\" in result ? result.status : result.status;\n    const body = \"error\" in result ? { error: result.error } : result.body;\n    return new Response(JSON.stringify(body), { status, headers: corsHeaders(request) });\n  } catch {\n    return new Response(JSON.stringify({ error: \"An unexpected error occurred. Please try again.\" }), {\n      status: 500,\n      headers: corsHeaders(request),\n    });\n  }\n}",
      "whyThisMatters": "These handlers are responsible for correct HTTP semantics and cross-origin behavior. Without tests, regressions can break clients or weaken boundary guarantees."
    },
    {
      "severity": "HIGH",
      "number": 14,
      "title": "No tests for MusicKit client flows (token fetching cache, script-load wait, catalog search, playlist create/add)",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "52-275",
      "category": "will-break",
      "description": "There is no in-scope coverage for the MusicKit integration, including multiple critical flows and error paths:\n- developer token fetch and caching TTL behavior (`fetchDeveloperToken`)\n- handling non-JSON token API responses\n- waiting for MusicKit script availability and timeout behavior (`waitForMusicKit`)\n- one-time configuration logic (`initMusicKit`) and failure modes when `NEXT_PUBLIC_APPLE_MUSIC_APP_ID` is unset\n- catalog search error parsing (`errors[]`) and caching/eviction behavior\n- authorization gating for creating playlists and adding tracks\n- input validation and error behavior for `addTracksToLibraryPlaylist` (invalid IDs, empty arrays)",
      "code": "export async function fetchDeveloperToken(): Promise<string> {\n  if (isTokenValid()) return cachedToken!;\n  // ...\n  const res = await fetch(devTokenUrl());\n  let data: { token?: string; error?: string };\n  try {\n    data = (await res.json()) as { token?: string; error?: string };\n  } catch {\n    throw new Error(\"Invalid response from Developer Token API (non-JSON).\");\n  }\n  if (!res.ok || data.error || !data.token) {\n    throw new Error(data.error ?? \"Failed to get Developer Token\");\n  }\n  cachedToken = data.token;\n  tokenExpiresAt = Date.now() + TOKEN_CACHE_TTL_MS;\n  return cachedToken;\n}\n\n// ...\nexport async function searchCatalog(term: string, limit = 5): Promise<AppleMusicTrack[]> {\n  // cache + eviction + MusicKit API call + errors[] handling\n}\n\n// ...\nexport async function createLibraryPlaylist(name: string): Promise<CreatePlaylistResult> {\n  const music = await initMusicKit();\n  if (!music.isAuthorized) throw new Error(\"Not authorized. Please connect Apple Music first.\");\n  // ...\n}\n\nexport async function addTracksToLibraryPlaylist(playlistId: string, songIds: string[]): Promise<void> {\n  if (songIds.length === 0) return;\n  if (!playlistId?.trim()) throw new Error(\"Invalid playlist ID\");\n  // ...\n  if (!music.isAuthorized) throw new Error(\"Not authorized. Please connect Apple Music first.\");\n  // ...\n  if (res?.errors && Array.isArray(res.errors) && res.errors.length > 0) {\n    throw new Error(`Adding tracks to playlist failed: ${detail}`);\n  }\n  if (validIds.length < songIds.length) {\n    throw new Error(`${dropped} of ${songIds.length} IDs were invalid and skipped; ${validIds.length} tracks added.`);\n  }\n}",
      "whyThisMatters": "MusicKit flows are core product functionality. Untested client logic here is likely to break in production with no early warning (especially around auth gating, script timing, and Apple API error formats)."
    },
    {
      "severity": "MEDIUM",
      "number": 15,
      "title": "`normalizeTrackName()` tests miss several important branches and normalization behaviors",
      "file": "packages/core/src/matching/normalize.ts",
      "lines": "5-18",
      "category": "will-break",
      "description": "Current tests cover parentheticals, unbalanced trailing `(`, feat/ft stripping, empty input, and basic space collapse. They do not cover:\n- `- live` suffix stripping (line 13)\n- collapsing of hyphen/en-dash/em-dash sequences into spaces (line 16)\n- multiple dash variants and combinations with surrounding whitespace",
      "code": "const s = name\n  .replace(/\\s*\\([^)]*\\)\\s*/g, \" \")\n  .replace(/\\s*\\([^)]*$/g, \" \")\n  .replace(/\\s*-\\s*live\\s*$/i, \"\")\n  .replace(/\\s*feat\\.?\\s*[^-]+(?:-\\s*[^-]+)*/gi, \"\")\n  .replace(/\\s*ft\\.?\\s*[^-]+(?:-\\s*[^-]+)*/gi, \"\")\n  .replace(/[\\s\\-–—]+/g, \" \")\n  .trim();",
      "whyThisMatters": "Normalization quality directly impacts catalog search matching. Untested normalization branches can regress silently and degrade match rates."
    },
    {
      "severity": "MEDIUM",
      "number": 16,
      "title": "`buildSearchQuery()` tests do not cover length-capping behavior (MAX_QUERY_LENGTH) or extreme inputs",
      "file": "packages/core/src/matching/search-query.ts",
      "lines": "3-15",
      "category": "will-break",
      "description": "Implementation caps both normalized track and artist to 200 chars. Current tests validate composition and trimming but do not validate the cap or behavior with very long strings.",
      "code": "const MAX_QUERY_LENGTH = 200;\n\nexport function buildSearchQuery(trackName: string, artistName?: string): string {\n  const track = normalizeTrackName(trackName).slice(0, MAX_QUERY_LENGTH);\n  const artist = (artistName?.trim() ?? \"\").slice(0, MAX_QUERY_LENGTH);\n  const parts = [track, artist].filter(Boolean);\n  return parts.join(\" \").replace(/\\s+/g, \" \").trim();\n}",
      "whyThisMatters": "Query length controls are an API-compatibility boundary. Regressions could reintroduce overly-long queries that fail against upstream limits."
    },
    {
      "severity": "MEDIUM",
      "number": 17,
      "title": "`mapSetlistFmToSetlist()` tests miss invalid song item filtering and `info` mapping nuances",
      "file": "packages/core/src/setlist/mapper.ts",
      "lines": "23-35",
      "category": "will-break",
      "description": "The mapper includes defensive filtering for song items that are null/non-object/missing `name` to avoid runtime throws, and maps `info` via `s.info ?? undefined` (which preserves empty strings). Current tests do not cover:\n- sets with `song` arrays containing `null`, primitives, objects without `name`\n- ensuring no throw occurs and filtering behaves as intended\n- behavior of `info` mapping when `info` is `\"\"` vs `undefined`",
      "code": "const songs = Array.isArray(fmSet.song) ? fmSet.song : [];\nconst entries: SetlistEntry[] = songs\n  .filter((s): s is SetlistFmSong => s != null && typeof s === \"object\" && \"name\" in s)\n  .map((s) => ({\n    name: s.name ?? \"\",\n    artist: artistName || undefined,\n    info: s.info ?? undefined,\n  }));\nif (entries.length > 0) sets.push(entries);",
      "whyThisMatters": "setlist.fm payloads can be inconsistent. Untested defensive mapping can regress into runtime crashes or subtle data-loss/shape changes that break downstream matching/export logic."
    }
  ],
  "auditId": "12-tests",
  "sourceFile": "12-tests.md"
}