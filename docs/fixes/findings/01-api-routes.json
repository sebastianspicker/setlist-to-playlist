{
  "auditTitle": "Next.js API Routes Deep Audit",
  "auditDate": "2026-02-15T06:32:52Z",
  "filesExamined": 3,
  "totalFindings": 10,
  "summary": {
    "critical": 1,
    "high": 1,
    "medium": 5,
    "low": 3
  },
  "findings": [
    {
      "severity": "CRITICAL",
      "number": 1,
      "title": "Public, unauthenticated setlist.fm proxy enables third-party abuse of the server-side API key (CORS is not access control)",
      "file": "apps/web/src/app/api/setlist/proxy/route.ts",
      "lines": "11-43",
      "category": "will-break",
      "description": "This route exposes a public GET endpoint that proxies requests to setlist.fm via `handleSetlistProxy(id)`. The only access gating in this file is CORS response headers. CORS only controls whether *browser JavaScript* can read a response; it does not prevent:\n- Server-to-server callers (curl, scripts, bots) from calling `/api/setlist/proxy` and receiving the full response.\n- Abuse that consumes setlist.fm quota / rate limits associated with the server’s `SETLISTFM_API_KEY`.\n\nAs written, any external party can use this endpoint as a free relay to setlist.fm (or as a traffic amplifier), potentially exhausting rate limits, causing service degradation, or triggering key revocation—without needing the client app.",
      "code": "export async function GET(request: NextRequest) {\n  const id = request.nextUrl.searchParams.get(\"id\") ?? request.nextUrl.searchParams.get(\"url\") ?? \"\";\n  // ...\n  try {\n    const result = await handleSetlistProxy(id);\n    const status = \"error\" in result ? result.status : result.status;\n    const body = \"error\" in result ? { error: result.error } : result.body;\n    return new Response(JSON.stringify(body), { status, headers: corsHeaders(request) });\n  } catch {\n    return new Response(\n      JSON.stringify({ error: \"An unexpected error occurred. Please try again.\" }),\n      { status: 500, headers: corsHeaders(request) }\n    );\n  }\n}",
      "whyThisMatters": "It creates an effectively public API-key-backed proxy surface. Even if browsers are blocked by CORS, non-browser clients can still exploit the endpoint and drain the API key’s quota or cause rate-limiting/outages."
    },
    {
      "severity": "HIGH",
      "number": 2,
      "title": "Public, unauthenticated Apple Developer Token issuance endpoint (CORS does not prevent non-browser clients from fetching tokens)",
      "file": "apps/web/src/app/api/apple/dev-token/route.ts",
      "lines": "9-23",
      "category": "will-break",
      "description": "This route returns an Apple Developer Token to any caller that can reach `/api/apple/dev-token`. Similar to the setlist proxy, the only “restriction” here is CORS response headers, which do not prevent server-side clients or bots from calling the endpoint and receiving the token.\n\nThere is also no evidence of throttling/rate limiting or any caller verification in this file; the endpoint is a public token mint + distribution surface.",
      "code": "export async function GET(request: NextRequest) {\n  try {\n    const result = await handleDevToken();\n    const status = \"error\" in result ? 503 : 200;\n    const headers = corsHeaders(request) as Record<string, string>;\n    headers[\"Cache-Control\"] = \"no-store\";\n    headers[\"Pragma\"] = \"no-cache\";\n    return new Response(JSON.stringify(result), { status, headers });\n  } catch {\n    const headers = corsHeaders(request) as Record<string, string>;\n    return new Response(\n      JSON.stringify({ error: \"An unexpected error occurred. Please try again.\" }),\n      { status: 500, headers }\n    );\n  }\n}",
      "whyThisMatters": "It expands the token’s exposure surface to the entire internet (not just the intended frontend), increasing risk of misuse and operational incidents."
    },
    {
      "severity": "MEDIUM",
      "number": 3,
      "title": "Query parameter precedence bug — `?id=` masks a valid `?url=...` due to `??` fallback semantics",
      "file": "apps/web/src/app/api/setlist/proxy/route.ts",
      "lines": "16-23",
      "category": "broken-logic",
      "description": "The route chooses between `id` and `url` using nullish coalescing (`??`). If a caller supplies `?id=` (empty string) and also provides a valid `?url=...`, `searchParams.get(\"id\")` returns `\"\"` (not `null`), so the code selects the empty `id` and never considers `url`. The request then fails with “Missing id or url query parameter” even though `url` was present.",
      "code": "const id = request.nextUrl.searchParams.get(\"id\") ?? request.nextUrl.searchParams.get(\"url\") ?? \"\";\nif (!id) {\n  return new Response(\n    JSON.stringify({ error: \"Missing id or url query parameter\" }),\n    { status: 400, headers: corsHeaders(request) }\n  );\n}",
      "whyThisMatters": "It causes surprising/incorrect behavior for clients and can lead to hard-to-debug failures when multiple parameters are present (including accidental `id=`)."
    },
    {
      "severity": "MEDIUM",
      "number": 4,
      "title": "`dev-token` handler sets `no-store`/`no-cache` only on the non-exception path; exception responses omit anti-caching headers",
      "file": "apps/web/src/app/api/apple/dev-token/route.ts",
      "lines": "10-23",
      "category": "will-break",
      "description": "In the try-path, the response is explicitly marked `Cache-Control: no-store` and `Pragma: no-cache`. In the exception path (`catch { ... }`), the handler does not set these headers.",
      "code": "// try-path\nheaders[\"Cache-Control\"] = \"no-store\";\nheaders[\"Pragma\"] = \"no-cache\";\nreturn new Response(JSON.stringify(result), { status, headers });\n\n// catch-path\nreturn new Response(\n  JSON.stringify({ error: \"An unexpected error occurred. Please try again.\" }),\n  { status: 500, headers }\n);",
      "whyThisMatters": "Token-related endpoints are sensitive to caching behavior. Divergent caching headers between success/error paths can lead to inconsistent intermediary behavior and operational confusion during incidents."
    },
    {
      "severity": "MEDIUM",
      "number": 5,
      "title": "Exception handling drops all error details (no capture, no logging), reducing debuggability during production failures (`dev-token`)",
      "file": "apps/web/src/app/api/apple/dev-token/route.ts",
      "lines": "17-23",
      "category": "will-break",
      "description": "The handler uses `catch { ... }` without capturing the thrown error object, and it returns a generic error message. There is no observable error detail in the response, and this file provides no logging/telemetry hook.",
      "code": "} catch {\n  const headers = corsHeaders(request) as Record<string, string>;\n  return new Response(\n    JSON.stringify({ error: \"An unexpected error occurred. Please try again.\" }),\n    { status: 500, headers }\n  );\n}",
      "whyThisMatters": "If unexpected exceptions occur (dependency failures, runtime issues, serialization edge cases), diagnosing the root cause becomes substantially harder."
    },
    {
      "severity": "MEDIUM",
      "number": 6,
      "title": "Exception handling drops all error details (no capture, no logging), reducing debuggability during production failures (`setlist/proxy`)",
      "file": "apps/web/src/app/api/setlist/proxy/route.ts",
      "lines": "33-42",
      "category": "will-break",
      "description": "Like the dev-token route, this handler uses a bare `catch { ... }` and returns a generic error message, with no captured error detail and no logging.",
      "code": "} catch {\n  return new Response(\n    JSON.stringify({ error: \"An unexpected error occurred. Please try again.\" }),\n    { status: 500, headers: corsHeaders(request) }\n  );\n}",
      "whyThisMatters": "When upstream fetching/parsing fails unexpectedly, operators and developers may see only generic client-side failures with limited actionable information."
    },
    {
      "severity": "MEDIUM",
      "number": 7,
      "title": "Responses are origin-dependent via `corsHeaders(request)` but no `Vary: Origin` header is set in route responses (cache interaction risk)",
      "file": "apps/web/src/app/api/health/route.ts",
      "lines": "6-8, 14-19",
      "category": "will-break",
      "description": "This route computes response headers from the request object via `corsHeaders(request)` / `corsHeadersForOptions(request)` but does not set `Vary: Origin`. If any caching layer (platform/CDN/proxy) is present and does not incorporate `Origin` into its cache key, it can cache and replay responses across different origins with mismatched CORS headers.",
      "code": "return new Response(null, { status: 204, headers: corsHeadersForOptions(request) });\n// ...\nreturn new Response(JSON.stringify(body), {\n  status: 200,\n  headers: corsHeaders(request),\n});",
      "whyThisMatters": "It can cause intermittent, hard-to-reproduce CORS failures (and confusing behavior differences between environments) when caches are involved."
    },
    {
      "severity": "LOW",
      "number": 8,
      "title": "Redundant / dead conditional — `status` assignment uses identical branches (`setlist/proxy`)",
      "file": "apps/web/src/app/api/setlist/proxy/route.ts",
      "lines": "34-37",
      "category": "slop",
      "description": "The `status` assignment is a ternary whose branches are identical, making it redundant and suggesting incomplete refactoring or copy/paste.",
      "code": "const result = await handleSetlistProxy(id);\nconst status = \"error\" in result ? result.status : result.status;\nconst body = \"error\" in result ? { error: result.error } : result.body;",
      "whyThisMatters": "It adds noise, weakens readability, and can conceal intended-but-missing logic (especially around error vs success handling)."
    },
    {
      "severity": "LOW",
      "number": 9,
      "title": "Type-unsafe header mutation via cast to `Record<string, string>` (`dev-token`)",
      "file": "apps/web/src/app/api/apple/dev-token/route.ts",
      "lines": "13-16",
      "category": "slop",
      "description": "`corsHeaders(request)` returns `HeadersInit`, but this handler casts it to `Record<string, string>` and mutates it in-place. This couples correctness to the current implementation detail that `corsHeaders()` returns a plain object; if the helper ever returns a `Headers` instance or an array-of-tuples, this pattern becomes fragile.",
      "code": "const headers = corsHeaders(request) as Record<string, string>;\nheaders[\"Cache-Control\"] = \"no-store\";\nheaders[\"Pragma\"] = \"no-cache\";",
      "whyThisMatters": "It’s a maintainability hazard that can introduce runtime bugs during refactors of shared CORS utilities."
    },
    {
      "severity": "LOW",
      "number": 10,
      "title": "Health endpoint provides a timestamp but does not include explicit cache directives",
      "file": "apps/web/src/app/api/health/route.ts",
      "lines": "10-19",
      "category": "slop",
      "description": "The health endpoint returns a timestamp intended to reflect “now,” but the response does not include explicit cache directives (e.g., no `Cache-Control` in this file). Depending on deployment infrastructure, intermediate caching could produce stale timestamps.",
      "code": "export async function GET(request: NextRequest) {\n  const body = handleHealth();\n  return new Response(JSON.stringify(body), {\n    status: 200,\n    headers: corsHeaders(request),\n  });\n}",
      "whyThisMatters": "A liveness/health signal that is accidentally cached can mislead monitoring, diagnostics, or load balancer health checks."
    }
  ],
  "auditId": "01-api-routes",
  "sourceFile": "01-api-routes.md"
}