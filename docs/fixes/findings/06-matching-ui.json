{
  "auditTitle": "Matching UI Deep Audit",
  "auditDate": "2026-02-15T07:04:41Z",
  "filesExamined": 4,
  "totalFindings": 16,
  "summary": {
    "critical": 1,
    "high": 6,
    "medium": 7,
    "low": 2
  },
  "findings": [
    {
      "severity": "CRITICAL",
      "number": 1,
      "title": "`useEffect` dependency can crash on non-array/nullable `sets` entries",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "14-25, 44-86",
      "category": "will-break",
      "description": "`flattenSetlist()` explicitly tolerates malformed `setlist.sets` items by skipping non-arrays (`if (!Array.isArray(set)) continue;`). However, the `useEffect` dependency array assumes every `setlist.sets` item has a `.length` property and is safe to access:\n\n- If `setlist.sets` contains `null`, `undefined`, or a non-object, `s.length` will throw at render time, crashing the matching UI.\n- This crash path is especially concerning because the code comment and runtime behavior already anticipate malformed set data.",
      "code": "for (const set of setlist.sets ?? []) {\n  if (!Array.isArray(set)) continue;\n}\n\n}, [setlist.id, (setlist.sets ?? []).map((s) => s.length).join(\",\")]);",
      "whyThisMatters": "A single malformed `sets` entry can take down the entire matching screen (hard crash), even though the rest of the component is written to tolerate malformed setlist data."
    },
    {
      "severity": "HIGH",
      "number": 2,
      "title": "Suggestion fetch effect dependencies are insufficient (stale suggestions + stale UI state)",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "44-86",
      "category": "broken-logic",
      "description": "The suggestions `useEffect` only re-runs when `setlist.id` or the comma-joined list of `set` lengths changes. It does not account for changes to:\n\n- Song names\n- Per-entry artist overrides\n- `setlist.artist` (used as fallback artist)\n- Entry order changes within sets\n- Any structural changes that preserve set lengths (e.g., swap two songs, rename, change artist)\n\nBecause the component stores a snapshot of `setlistEntry` inside state (`matches`), missing an effect re-run can leave the UI showing outdated entries and suggestions.",
      "code": "useEffect(() => {\n  const entriesFlat = flattenSetlist(setlist);\n  // ...\n  setMatches(entriesFlat.map((setlistEntry) => ({ setlistEntry, appleTrack: null })));\n  // ...\n// eslint-disable-next-line react-hooks/exhaustive-deps\n}, [setlist.id, (setlist.sets ?? []).map((s) => s.length).join(\",\")]);",
      "whyThisMatters": "Edits/refreshes to the setlist that don’t change lengths can silently leave users matching tracks for an older version of the setlist."
    },
    {
      "severity": "HIGH",
      "number": 3,
      "title": "UI renders from derived state snapshots, not the `setlist` prop (enables desync)",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "33-37, 44-53, 140-146",
      "category": "broken-logic",
      "description": "The displayed setlist content (song name/artist) comes from `matches` state (`row.setlistEntry`) rather than directly from the `setlist` prop. Since `matches` is initialized from props and only conditionally re-synced by the effect, any missed dependency update (or partial update) leaves the rendered list potentially out of sync with the actual `setlist` prop.",
      "code": "const [matches, setMatches] = useState<MatchRow[]>(() =>\n  entries.map((setlistEntry) => ({ setlistEntry, appleTrack: null }))\n);\n\n<strong>{row.setlistEntry?.name ?? \"—\"}</strong>\n{row.setlistEntry?.artist && (\n  <span> — {row.setlistEntry.artist}</span>\n)}",
      "whyThisMatters": "Users can be shown (and make matching decisions against) stale setlist entries, which can cascade into incorrect playlist exports."
    },
    {
      "severity": "HIGH",
      "number": 4,
      "title": "Unstable list keys (`key={index}`) can mis-associate rows and user selections",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "131-139",
      "category": "will-break",
      "description": "The main list uses array index keys. If rows are inserted/removed/reordered (including via setlist refresh or re-flattening), React may reuse DOM/state in a way that visually attaches the wrong match/search UI to the wrong setlist entry.",
      "code": "{matches.map((row, index) => (\n  <li key={index}>",
      "whyThisMatters": "A user can believe they’re changing the match for one song while actually modifying a different row after a setlist update or reordering."
    },
    {
      "severity": "HIGH",
      "number": 5,
      "title": "Suggestion-fetch failures are silently treated as “No match” (no error surface)",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "55-77, 148-157",
      "category": "will-break",
      "description": "All failures during suggestion fetching (including MusicKit not loaded, dev token fetch failing, Apple API errors) are caught and converted into `appleTrack: null`, with no user-visible indication that the suggestion system failed.\n\nThe rendered UI shows `No match` for both “no catalog result” and “system error”.",
      "code": "try {\n  const tracks = await searchCatalog(query, 1);\n  const track = tracks[0] ?? null;\n  // ...\n} catch {\n  setMatches((prev) => { /* ... */ appleTrack: null });\n}\n\n{row.appleTrack ? (\n  <span>→ {row.appleTrack.name}</span>\n) : (\n  <span style={{ color: \"#888\" }}>No match</span>\n)}",
      "whyThisMatters": "A broken integration (token/API/script) can look identical to legitimate “no match” results, preventing users from diagnosing why matching is empty."
    },
    {
      "severity": "MEDIUM",
      "number": 6,
      "title": "Suggestions are fetched sequentially with a global loading indicator (slow + unclear progress)",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "55-80, 125-129",
      "category": "slop",
      "description": "Suggestions are fetched in a `for` loop with `await` per entry, making total time scale linearly with setlist size. The UI shows a single “Fetching suggestions…” message until the entire loop completes.",
      "code": "for (let i = 0; i < entriesFlat.length; i++) {\n  const tracks = await searchCatalog(query, 1);\n  // ...\n}\n{loadingSuggestions && <p role=\"status\">Fetching suggestions…</p>}",
      "whyThisMatters": "Large setlists can feel sluggish with limited feedback, even though partial results may be appearing row-by-row."
    },
    {
      "severity": "HIGH",
      "number": 7,
      "title": "Manual search results can display under the wrong row (in-flight search not tied to index)",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "100-114, 160-167, 181-226",
      "category": "broken-logic",
      "description": "Manual search uses global `searchResults`/`searching` state that is not associated with the specific row being searched. If the user changes `searchingIndex` while a search is in flight (by clicking “Change” on a different row), the in-flight promise resolves and writes results into the global `searchResults`, which will then render under whichever row is currently open.",
      "code": "async function runSearch(index: number) {\n  // ...\n  const tracks = await searchCatalog(q, 8);\n  setSearchResults(tracks);\n}\n\nonClick={() => {\n  setSearchingIndex(index);\n  setSearchQuery(\"\");\n  setSearchResults([]);\n}}\n\n{searchingIndex === index && (\n  <>\n    {/* ... */}\n    {searchResults.length > 0 && (\n      <ul>\n        {searchResults.map((track) => (\n          <li key={track.id}>\n            <button onClick={() => setMatch(index, track)}>{track.name}</button>\n          </li>\n        ))}\n      </ul>\n    )}\n  </>\n)}",
      "whyThisMatters": "Users can accidentally pick a result that was fetched for a different song, leading to incorrect matching selections."
    },
    {
      "severity": "MEDIUM",
      "number": 8,
      "title": "Manual search requests can race (no cancellation / last-resolve-wins)",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "100-114",
      "category": "will-break",
      "description": "`runSearch()` does not cancel prior requests or guard against out-of-order resolution. Multiple searches (rapid clicks, Enter presses, or searches with changing queries) can resolve in an unexpected order and overwrite `searchResults` with stale data.",
      "code": "setSearching(true);\ntry {\n  const tracks = await searchCatalog(q, 8);\n  setSearchResults(tracks);\n} finally {\n  setSearching(false);\n}",
      "whyThisMatters": "Search results can flicker or regress, and the user may select from an older result set without realizing it."
    },
    {
      "severity": "MEDIUM",
      "number": 9,
      "title": "Manual search has no explicit “no results” or “error” UI state",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "106-113, 204-226",
      "category": "unfinished",
      "description": "When search returns zero results or throws, the UI just shows nothing (empty area). There is no user-visible distinction between:\n\n- “No results for this query”\n- “Search failed (token, network, MusicKit, API error)”\n- “Haven’t searched yet”",
      "code": "} catch {\n  setSearchResults([]);\n}\n\n{searchResults.length > 0 && (\n  <ul>\n    {searchResults.map((track) => (\n      <li key={track.id}>...</li>\n    ))}\n  </ul>\n)}",
      "whyThisMatters": "Users can’t tell whether the system is working, which increases repeated retries and confusion."
    },
    {
      "severity": "LOW",
      "number": 10,
      "title": "Search input is placeholder-only (missing accessible label)",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "183-195",
      "category": "slop",
      "description": "The search input has no associated `<label>` and relies on placeholder text. This reduces accessibility and can make the control ambiguous for assistive technologies.",
      "code": "<input\n  type=\"text\"\n  value={searchQuery}\n  onChange={(e) => setSearchQuery(e.target.value)}\n  placeholder=\"Search Apple Music…\"\n/>",
      "whyThisMatters": "Accessibility regressions can block some users from completing manual matching."
    },
    {
      "severity": "MEDIUM",
      "number": 11,
      "title": "Manual-search UI state is not reset when the setlist changes",
      "file": "apps/web/src/features/matching/MatchingView.tsx",
      "lines": "38-43, 44-53, 88-98",
      "category": "will-break",
      "description": "On setlist changes, the effect reinitializes `matches` but does not reset `searchingIndex`, `searchQuery`, `searchResults`, or `searching`. This can leave:\n\n- Stale query/results logically associated with an older setlist\n- `searchingIndex` pointing at a different entry after refresh/reorder\n- A hidden search panel (index out of range) with leftover state",
      "code": "const [searchingIndex, setSearchingIndex] = useState<number | null>(null);\nconst [searchQuery, setSearchQuery] = useState(\"\");\nconst [searchResults, setSearchResults] = useState<AppleMusicTrack[]>([]);\nconst [searching, setSearching] = useState(false);\n\nsetMatches(entriesFlat.map((setlistEntry) => ({ setlistEntry, appleTrack: null })));",
      "whyThisMatters": "Users can see mismatched search behavior after setlist refreshes, including results appearing unexpectedly for the “wrong” context."
    },
    {
      "severity": "HIGH",
      "number": 12,
      "title": "`searchCatalog` cache key ignores `limit` and `storefront` (truncates manual search + cross-region staleness)",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "149-203",
      "category": "broken-logic",
      "description": "`searchCatalog(term, limit)` caches results only by `term`. It does not include `limit` or the resolved `storefront` in the cache key:\n\n- In matching flow, suggestions call `searchCatalog(query, 1)` first, caching only 1 result for that `term`.\n- Manual search later calls `searchCatalog(q, 8)` and will return the cached 1-result array, preventing users from seeing broader options.\n- If storefront changes (e.g., after authorization or region detection), cached results can be returned for the wrong storefront.",
      "code": "const entry = searchCache.get(term);\nif (entry && Date.now() < entry.expires) return entry.tracks;\n\nconst storefront = music.storefrontId || \"us\";\n// ...\nsearchCache.set(term, { tracks, expires: Date.now() + SEARCH_CACHE_TTL_MS });",
      "whyThisMatters": "The “Change → Search” flow can be functionally broken (only 1 option shown) in common usage, and results may not match the user’s actual storefront context."
    },
    {
      "severity": "MEDIUM",
      "number": 13,
      "title": "`waitForMusicKit()` leaves a live timeout even after resolving (timer accumulation)",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "73-93",
      "category": "slop",
      "description": "When `window.MusicKit` becomes available, the interval is cleared and the promise resolves, but the `setTimeout` is never cleared. The timeout will still fire later (up to 10s), performing work and calling `reject` after the promise already resolved.\n\nRepeated calls before MusicKit loads (or in concurrent init paths) can leave many pending timeouts.",
      "code": "const check = setInterval(() => {\n  if (window.MusicKit) {\n    clearInterval(check);\n    resolve(window.MusicKit);\n  }\n}, 50);\nsetTimeout(() => {\n  clearInterval(check);\n  reject(new Error(\"MusicKit script did not load\"));\n}, 10000);",
      "whyThisMatters": "This is an avoidable timer leak pattern that can add noise and overhead during initialization-heavy flows."
    },
    {
      "severity": "MEDIUM",
      "number": 14,
      "title": "`initMusicKit()` / `fetchDeveloperToken()` have no in-flight guard (concurrent calls can race)",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "53-70, 96-122",
      "category": "will-break",
      "description": "Both token fetching and MusicKit configuration rely on module-level caches (`cachedToken`, `configuredInstance`) but do not gate concurrent calls:\n\n- If multiple components (or double-clicks) call `initMusicKit()` before `configuredInstance` is set, they can run parallel token fetches and parallel `MusicKit.configure()` calls.\n- `configuredInstance` is assigned after async operations; whichever concurrent call finishes last “wins,” potentially overwriting a prior configured instance.",
      "code": "let configuredInstance: MusicKitInstance | null = null;\n\nexport async function initMusicKit(): Promise<MusicKitInstance> {\n  if (configuredInstance) return configuredInstance;\n  const token = await fetchDeveloperToken();\n  const MusicKit = await waitForMusicKit();\n  const configureResult = MusicKit.configure({ developerToken: token, /* ... */ });\n  // ...\n  configuredInstance = MusicKit.getInstance();\n  return configuredInstance;\n}",
      "whyThisMatters": "Racing initialization increases the chance of inconsistent behavior (multiple token requests/configure calls) during matching/search/authorization flows."
    },
    {
      "severity": "MEDIUM",
      "number": 15,
      "title": "Connect flow allows concurrent authorization attempts (re-entrancy)",
      "file": "apps/web/src/features/matching/ConnectAppleMusic.tsx",
      "lines": "21-40, 45-57, 71-77",
      "category": "will-break",
      "description": "`handleAuthorize()` does not guard against re-entrancy. While the main button is disabled via `disabled={loading}`, there is a window where the handler can be triggered multiple times (double-click before React state applies), and the error “Try again” button does not check `loading` at all (it relies on `setError(null)` hiding the alert after state updates).",
      "code": "async function handleAuthorize() {\n  setError(null);\n  setLoading(true);\n  try {\n    await initMusicKit();\n    await authorizeMusicKit();\n    onAuthorized?.();\n  } finally {\n    setLoading(false);\n  }\n}\n\n<button onClick={handleAuthorize} disabled={loading}>...</button>\n\n<button type=\"button\" onClick={handleAuthorize}>Try again</button>",
      "whyThisMatters": "Concurrent authorization flows can create unpredictable UX (multiple prompts / racing init calls) and magnify the initialization race risks in `musickit.ts`."
    },
    {
      "severity": "LOW",
      "number": 16,
      "title": "Error classification is fragile and can surface raw internal messages",
      "file": "apps/web/src/features/matching/ConnectAppleMusic.tsx",
      "lines": "29-37",
      "category": "slop",
      "description": "The code matches substrings in the error message (`includes(\"cancel\")`, `includes(\"denied\")`, etc.) in a case-sensitive way and otherwise displays the raw error message. This is brittle and may lead to inconsistent user-facing messaging depending on the exact casing/wording of underlying errors.",
      "code": "const friendly =\n  message.includes(\"cancel\") || message.includes(\"denied\")\n    ? \"You cancelled or denied access. Click below to try again.\"\n    : message.includes(\"revoked\") || message.includes(\"unauthorized\")\n      ? \"Apple Music access was revoked. Click below to connect again.\"\n      : message;",
      "whyThisMatters": "Users may see confusing or overly-technical errors, and “friendly” messaging may fail to trigger for the same underlying scenario if message casing differs."
    }
  ],
  "auditId": "06-matching-ui",
  "sourceFile": "06-matching-ui.md"
}