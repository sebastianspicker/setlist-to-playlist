{
  "auditTitle": "Types & Interfaces Deep Audit",
  "auditDate": "2026-02-15",
  "filesExamined": 35,
  "totalFindings": 17,
  "summary": {
    "critical": 2,
    "high": 2,
    "medium": 9,
    "low": 4
  },
  "findings": [
    {
      "severity": "CRITICAL",
      "number": 1,
      "title": "`SetlistFmResponse` models `set` but real responses use `sets: { set: ... }` (songs can be dropped)",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "34-44",
      "category": "will-break",
      "description": "`SetlistFmResponse` defines `set?: SetlistFmSet[]`, implying the set array is at the top level. Multiple real-world examples show setlist.fm responses using a wrapper object `sets` containing `set` (array). With the current type, downstream code is encouraged to read `raw.set`, and valid responses shaped as `raw.sets.set` will appear as “no sets”.",
      "code": "export interface SetlistFmResponse {\n  id: string;\n  versionId?: string;\n  eventDate: string;\n  artist: SetlistFmArtist;\n  venue?: SetlistFmVenue;\n  tour?: { name?: string };\n  set?: SetlistFmSet[];\n  info?: string;\n  url?: string;\n}",
      "whyThisMatters": "This can result in silently importing a setlist with **0 tracks**, even when the API returned songs, breaking the core “import → preview → match → export” flow."
    },
    {
      "severity": "CRITICAL",
      "number": 2,
      "title": "Mapper only reads `raw.set`, so `raw.sets.set` responses map to empty `sets`",
      "file": "packages/core/src/setlist/mapper.ts",
      "lines": "20-35",
      "category": "will-break",
      "description": "The mapper uses `Array.isArray(raw.set)` and otherwise treats the setlist as having no sets. If the incoming payload uses `sets: { set: [...] }`, this produces an empty `Setlist.sets` and downstream UIs show zero tracks.",
      "code": "const sets: SetlistEntry[][] = [];\nconst fmSets = Array.isArray(raw.set) ? raw.set : [];\n\nfor (const fmSet of fmSets) {\n  if (!fmSet || typeof fmSet !== \"object\") continue;\n  const songs = Array.isArray(fmSet.song) ? fmSet.song : [];\n  // ...\n}",
      "whyThisMatters": "A valid API response shape mismatch becomes a total functional failure (no songs to preview/match/export) without an obvious error."
    },
    {
      "severity": "HIGH",
      "number": 3,
      "title": "Web client casts proxy JSON to `SetlistFmResponse` without validating shape (type safety is illusory)",
      "file": "apps/web/src/features/setlist-import/SetlistImportView.tsx",
      "lines": "48-72",
      "category": "will-break",
      "description": "The client parses JSON into `{ error?: string } | SetlistFmResponse`, and on success forcibly casts `data as SetlistFmResponse` and passes it to the mapper. The only “validation” is `!res.ok || \"error\" in data`, which does not assert required fields (`artist`, `eventDate`, and especially the `set` vs `sets` structure). This can convert a real API payload into a mapped setlist with empty tracks (or throw inside the mapper).",
      "code": "let data: { error?: string } | SetlistFmResponse;\ntry {\n  data = (await res.json()) as { error?: string } | SetlistFmResponse;\n} catch { /* ... */ }\n\nif (!res.ok || \"error\" in data) { /* ... */ }\n\nconst mapped = mapSetlistFmToSetlist(data as SetlistFmResponse);\nsetSetlist(mapped);\nsetStep(\"preview\");",
      "whyThisMatters": "Type assertions can hide real API drift until runtime, causing broken imports that look “successful” (no explicit error) but contain no songs."
    },
    {
      "severity": "HIGH",
      "number": 4,
      "title": "MusicKit JS surface is modeled ad-hoc (`music.music.api`) and conflicts with common/typed `api` surfaces (risk of runtime `undefined`)",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "27-35, 187-190, 222-228, 262-264",
      "category": "will-break",
      "description": "The local `MusicKitInstance` interface defines a `music: { api: (path, options) => Promise<unknown> }`, and all Apple Music calls are made via `music.music.api(...)`. Widely used typings and references for MusicKit JS expose an `api` object on the instance (e.g. `music.api.music(...)`) rather than an extra `.music` nesting. If the real runtime instance does not match this hand-written shape, calls like `music.music.api` will throw (`Cannot read properties of undefined`).",
      "code": "interface MusicKitInstance {\n  authorize(): Promise<string>;\n  unauthorize(): Promise<void>;\n  isAuthorized: boolean;\n  storefrontId: string;\n  music: {\n    api: (path: string, options?: { method?: string; data?: unknown }) => Promise<unknown>;\n  };\n}\n\n// Usage:\nconst data = (await music.music.api(path)) as { /* ... */ };",
      "whyThisMatters": "This is a single-point-of-failure abstraction: if the real MusicKit API surface differs, **catalog search, playlist create, and add-tracks all fail**."
    },
    {
      "severity": "MEDIUM",
      "number": 5,
      "title": "`SetlistFmVenue.city` / `country` shape is truncated and has incorrect required fields vs observed payloads",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "13-18",
      "category": "slop",
      "description": "`city` is modeled as `{ name: string; country?: { code: string } }`, but observed payloads commonly include `city.id`, `state`, `stateCode`, `coords`, and `country.name`, and may include empty objects for `country` in some cases. As written, if `country` is present but missing `code`, the type encourages unsafe access patterns.",
      "code": "export interface SetlistFmVenue {\n  name: string;\n  id?: string;\n  city?: { name: string; country?: { code: string } };\n  url?: string;\n}",
      "whyThisMatters": "When UI/logic later starts using location data (city/country), these types can create false confidence and lead to undefined reads or incorrect displays."
    },
    {
      "severity": "MEDIUM",
      "number": 6,
      "title": "`SetlistFmSong.cover` / `with` typed as `unknown` despite being documented/observed as artist objects",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "20-26",
      "category": "slop",
      "description": "`cover` and `with` are typed as `unknown`, losing a clear domain shape (artist-like objects). This pushes consumers toward unsafe casting or ignoring useful metadata.",
      "code": "export interface SetlistFmSong {\n  name: string;\n  info?: string;\n  cover?: unknown;\n  with?: unknown;\n  tape?: boolean;\n}",
      "whyThisMatters": "It prevents type-safe handling of common setlist features (covers, guest performers) and increases the chance of ad-hoc casts later."
    },
    {
      "severity": "MEDIUM",
      "number": 7,
      "title": "`SetlistFmResponse` omits `lastUpdated` and weakens `versionId` / `url` optionality compared to documented contracts",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "34-44",
      "category": "slop",
      "description": "The type does not include `lastUpdated`, and marks `versionId` and `url` optional. Documentation indicates `lastUpdated` and `url` exist on the Setlist object; weakening these fields makes it easy to forget attribution (`url`) and obscures update/refresh logic (`lastUpdated`, `versionId`).",
      "code": "export interface SetlistFmResponse {\n  id: string;\n  versionId?: string;\n  eventDate: string;\n  // ...\n  url?: string;\n}",
      "whyThisMatters": "Missing/optional attribution fields can become a compliance/UX issue, and missing update metadata makes caching/refresh behavior harder to reason about."
    },
    {
      "severity": "MEDIUM",
      "number": 8,
      "title": "`SetlistFmSet.song` is required in the type, but mapper treats it as optional/malformed (type and runtime expectations disagree)",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "28-32",
      "category": "slop",
      "description": "The type requires `song: SetlistFmSong[]`, but the mapper defensively does `Array.isArray(fmSet.song) ? fmSet.song : []`, implying `song` may be missing or non-array at runtime. This mismatch means the type contract does not reflect real-world variability or the app’s own defensive posture.",
      "code": "export interface SetlistFmSet {\n  name?: string;\n  encore?: number;\n  song: SetlistFmSong[];\n}",
      "whyThisMatters": "Misleading required fields encourage consumers to skip checks, while production data can still be malformed (or shaped differently), leading to runtime errors or silent data loss."
    },
    {
      "severity": "MEDIUM",
      "number": 9,
      "title": "Mapper’s type guard `s is SetlistFmSong` is unsound (only checks `\"name\" in s`)",
      "file": "packages/core/src/setlist/mapper.ts",
      "lines": "27-33",
      "category": "slop",
      "description": "The filter claims to narrow to `SetlistFmSong` but only asserts that `name` exists as a key, not that `name` is a string (or that other fields match). This undermines the value of the `SetlistFmSong` type within the mapper and can let unexpected values through as if they were valid songs.",
      "code": ".filter((s): s is SetlistFmSong => s != null && typeof s === \"object\" && \"name\" in s)\n.map((s) => ({\n  name: s.name ?? \"\",\n  artist: artistName || undefined,\n  info: s.info ?? undefined,\n}));",
      "whyThisMatters": "It can propagate non-string `name` values into `SetlistEntry.name` (typed as `string`), causing surprising UI behavior and making debugging harder."
    },
    {
      "severity": "MEDIUM",
      "number": 10,
      "title": "Proxy and fetcher return `unknown` bodies, forcing unsafe assertions across the API boundary",
      "file": "apps/api/src/routes/setlist/proxy.ts",
      "lines": "6-8",
      "category": "slop",
      "description": "Successful proxy responses carry `body: unknown`, and the proxy does not validate/normalize the upstream response into a known `SetlistFmResponse` shape before returning it.",
      "code": "export type ProxyResponse =\n  | { body: unknown; status: number }\n  | { error: string; status: number };",
      "whyThisMatters": "Clients must cast to a presumed shape, which can easily drift from reality and break at runtime (especially given `set` vs `sets` uncertainty)."
    },
    {
      "severity": "MEDIUM",
      "number": 11,
      "title": "setlist.fm fetcher result type also uses `body: unknown`, reinforcing downstream casts",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "72-74, 96-100",
      "category": "slop",
      "description": "`FetchSetlistResult` uses `body: unknown` even on `ok: true`, and stores cached payloads as `unknown`. This spreads uncertainty downstream and makes it hard to prove that the mapper receives the expected setlist shape.",
      "code": "export type FetchSetlistResult =\n  | { ok: true; body: unknown }\n  | { ok: false; status: number; message: string };\n\nbody = (await res.json()) as unknown;",
      "whyThisMatters": "It encourages “cast-and-pray” patterns at the edges and increases the likelihood that shape drift becomes a runtime failure."
    },
    {
      "severity": "MEDIUM",
      "number": 12,
      "title": "`DevTokenResponse` is duplicated and weakened in the web client (union vs “all-optional” object)",
      "file": "apps/api/src/routes/apple/dev-token.ts",
      "lines": "3",
      "category": "slop",
      "description": "The API defines a strict union `{ token } | { error }`, but the client models the parsed JSON as `{ token?: string; error?: string }`, which permits impossible states (`{}` or `{ token, error }`) and loses the mutual exclusivity guarantee.",
      "code": "export type DevTokenResponse = { token: string } | { error: string };",
      "whyThisMatters": "A weaker client type makes it easier for unexpected server responses to slip through without being caught by TypeScript (and complicates reasoning about control flow)."
    },
    {
      "severity": "MEDIUM",
      "number": 13,
      "title": "MusicKit `configure()` return type is overly broad, forcing “thenable duck-typing”",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "9-12, 112-120",
      "category": "slop",
      "description": "`configure()` is typed as returning `Promise<MusicKitInstance> | MusicKitInstance | void`, and the implementation checks for `.then` at runtime. This suggests the code does not know the real contract and makes the integration more fragile.",
      "code": "interface MusicKitGlobal {\n  configure(options: MusicKitConfigureOptions): Promise<MusicKitInstance> | MusicKitInstance | void;\n  getInstance(): MusicKitInstance;\n}\n\nif (configureResult && typeof (configureResult as Promise<unknown>).then === \"function\") {\n  await (configureResult as Promise<MusicKitInstance>);\n}",
      "whyThisMatters": "If the real return value differs (or is a non-Promise thenable), initialization and all dependent API calls can behave unpredictably."
    },
    {
      "severity": "MEDIUM",
      "number": 14,
      "title": "MusicKit API response typing is under-specified and can silently produce empty-string track names",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "187-200, 37-41",
      "category": "slop",
      "description": "The search response is cast with optional `attributes?.name`, and the mapping falls back to `\"\"` when missing. Meanwhile, `AppleMusicTrack.name` is typed as required `string`, implying it’s always meaningful. This mismatch can silently create blank track labels and degrade matching/selection UX.",
      "code": "export interface AppleMusicTrack {\n  id: string;\n  name: string;\n  artistName?: string;\n}\n\nconst tracks: AppleMusicTrack[] = songs.map((s) => ({\n  id: s.id,\n  name: s.attributes?.name ?? \"\",\n  artistName: s.attributes?.artistName,\n}));",
      "whyThisMatters": "It hides API/typing issues by substituting empty strings, leading to confusing UI states and potentially worse matching behavior."
    },
    {
      "severity": "MEDIUM",
      "number": 15,
      "title": "Apple track shapes are duplicated across core and web (risk of drift/inconsistent optionality)",
      "file": "packages/core/src/matching/types.ts",
      "lines": "1-5",
      "category": "slop",
      "description": "Core defines `AppleTrack`, while web defines `AppleMusicTrack` with a similar shape. These are parallel contracts that can drift (fields, optionality, meaning) without TypeScript catching mismatches across package boundaries.",
      "code": "export interface AppleTrack {\n  id: string;\n  name: string;\n  artistName?: string;\n}",
      "whyThisMatters": "Type duplication across layers increases maintenance burden and makes subtle inconsistencies (e.g. required vs optional fields) more likely over time."
    },
    {
      "severity": "LOW",
      "number": 16,
      "title": "Placeholder type exported publicly but unused (`AppleCatalogTrack`)",
      "file": "packages/core/src/apple/types.ts",
      "lines": "1-8",
      "category": "dead-end",
      "description": "`AppleCatalogTrack` is explicitly labeled “Placeholder” and exported via `@repo/core` (through `packages/core/src/apple/index.ts`), but no usages exist in the repo. Its high optionality (`attributes?`, `name?`) also indicates it is not a stable contract.",
      "code": "/** Placeholder for Apple Music API types used by core (e.g. catalog track). */\nexport interface AppleCatalogTrack {\n  id: string;\n  attributes?: {\n    name?: string;\n    artistName?: string;\n  };\n}",
      "whyThisMatters": "Dead, placeholder exports tend to rot and can mislead consumers into treating them as authoritative contracts."
    },
    {
      "severity": "LOW",
      "number": 17,
      "title": "`Setlist.sets` is required by type but treated as optional in web usage (inconsistent contract assumptions)",
      "file": "packages/core/src/setlist/types.ts",
      "lines": "10-21",
      "category": "slop",
      "description": "`Setlist.sets` is required (`SetlistEntry[][]`), but web code frequently uses `setlist.sets ?? []` patterns, implying it may be missing/undefined. This inconsistency suggests the domain contract isn’t trusted by consumers.",
      "code": "export interface Setlist {\n  // ...\n  /** Ordered list of tracks/songs */\n  sets: SetlistEntry[][];\n}",
      "whyThisMatters": "It signals contract ambiguity: either the type is too strict for real runtime states, or consumers are defensive due to prior shape problems—both reduce TypeScript’s effectiveness."
    }
  ],
  "auditId": "11-types",
  "sourceFile": "11-types.md"
}