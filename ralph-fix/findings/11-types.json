{
  "auditTitle": "Types & Interfaces",
  "auditDate": "2026-02-14T11:21:05Z",
  "filesExamined": 39,
  "totalFindings": 16,
  "summary": {
    "critical": 0,
    "high": 3,
    "medium": 11,
    "low": 2
  },
  "findings": [
    {
      "severity": "HIGH",
      "number": 1,
      "title": "setlist.fm “sets” shape mismatch risk (`set` vs `sets: { set: ... }`) can silently drop all songs",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "34-42",
      "category": "will-break",
      "description": "`SetlistFmResponse` models the set structure as a top-level `set?: SetlistFmSet[]`. Official setlist.fm docs describe a top-level `set` array, but setlist.fm community reports indicate real API responses can instead return `sets: { set: [...] }` (a wrapper object), creating a shape mismatch at the exact field the app relies on for songs. With the current types, that wrapper shape is not representable, encouraging unsafe casts and making it easy for the mapper to “successfully” produce an empty `sets` array (no tracks) rather than failing loudly.",
      "code": "export interface SetlistFmResponse {\n  id: string;\n  versionId?: string;\n  eventDate: string;\n  artist: SetlistFmArtist;\n  venue?: SetlistFmVenue;\n  tour?: { name?: string };\n  set?: SetlistFmSet[];\n  info?: string;\n  url?: string;\n}",
      "whyThisMatters": "If the upstream payload uses a `sets` wrapper, the app will import a setlist with **zero tracks** and proceed through matching/export with empty data, producing broken UX and wrong playlists."
    },
    {
      "severity": "HIGH",
      "number": 2,
      "title": "Mapper hardcodes `raw.set` and has no typed path for `sets.set` wrapper",
      "file": "packages/core/src/setlist/mapper.ts",
      "lines": "20-25",
      "category": "will-break",
      "description": "The mapper reads `raw.set` directly. If the upstream response shape is `sets: { set: [...] }`, the mapper will treat it as “no sets” and return `sets: []` without any error, because it defaults to an empty array.",
      "code": "const sets: SetlistEntry[][] = [];\nconst fmSets = Array.isArray(raw.set) ? raw.set : [];\n\nfor (const fmSet of fmSets) {\n  if (!fmSet || typeof fmSet !== \"object\") continue;\n  const songs = Array.isArray(fmSet.song) ? fmSet.song : [];",
      "whyThisMatters": "This is a silent failure mode: the type system and runtime checks won’t catch it, and downstream UI logic will just see an empty setlist."
    },
    {
      "severity": "HIGH",
      "number": 3,
      "title": "MusicKit JS typings are ad-hoc and conflict with documented `music.api` surface (risk of runtime `undefined` access)",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "27-35",
      "category": "will-break",
      "description": "The local `MusicKitInstance` type defines a nested `music: { api: (...) => Promise<unknown> }`, and the implementation calls `music.music.api(...)` (e.g. catalog search, playlist creation, add-tracks). Apple’s MusicKit JS documentation shows the instance surface centered on `music.api...` (object with methods), not a nested `music.music.api` function. Because these types are handwritten, TypeScript will accept usages that may not exist at runtime.",
      "code": "interface MusicKitInstance {\n  authorize(): Promise<string>;\n  unauthorize(): Promise<void>;\n  isAuthorized: boolean;\n  storefrontId: string;\n  music: {\n    api: (path: string, options?: { method?: string; data?: unknown }) => Promise<unknown>;\n  };\n}",
      "whyThisMatters": "If the runtime instance does not match this guessed shape, calls like `music.music.api(...)` can throw (e.g. “Cannot read properties of undefined”), breaking matching and playlist export flows."
    },
    {
      "severity": "MEDIUM",
      "number": 4,
      "title": "`SetlistFmResponse` omits documented `lastUpdated` field (and treats `versionId` as optional)",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "34-44",
      "category": "slop",
      "description": "Official setlist.fm setlist docs include `lastUpdated` and show `versionId` as a normal field. This type omits `lastUpdated` entirely and makes `versionId` optional. Even if the app doesn’t currently use `lastUpdated`, exporting these types from `@repo/core` makes them part of a public contract and increases drift risk.",
      "code": "export interface SetlistFmResponse {\n  id: string;\n  versionId?: string;\n  eventDate: string;\n  artist: SetlistFmArtist;\n  // ...\n}",
      "whyThisMatters": "Missing/incorrect fields in a “source-of-truth” API type encourage downstream `as any`/casting, and can cause subtle bugs when new features start relying on fields that the types claim don’t exist."
    },
    {
      "severity": "MEDIUM",
      "number": 5,
      "title": "`SetlistFmArtist` is missing documented `disambiguation` (and other known fields)",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "6-11",
      "category": "slop",
      "description": "setlist.fm docs show `artist.disambiguation` as part of the artist shape. The core type doesn’t include it, and it also doesn’t model other commonly present fields seen in docs/examples. This is a partial type presented as “Types for the setlist.fm REST API response”, which increases mismatch risk for consumers.",
      "code": "export interface SetlistFmArtist {\n  name: string;\n  mbid?: string;\n  sortName?: string;\n  url?: string;\n}",
      "whyThisMatters": "Consumers of `@repo/core` types can’t accurately type against documented responses and may “paper over” mismatches with unsafe casts."
    },
    {
      "severity": "MEDIUM",
      "number": 6,
      "title": "`SetlistFmSong.cover` / `with` are `unknown` but documented as `artist` objects",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "20-26",
      "category": "slop",
      "description": "setlist.fm docs model `cover` and `with` as objects (artist-like). Typing them as `unknown` is an overuse of `unknown` that prevents safe access and invites untyped narrowing/casting wherever they’re needed.",
      "code": "export interface SetlistFmSong {\n  name: string;\n  info?: string;\n  cover?: unknown;\n  with?: unknown;\n  tape?: boolean;\n}",
      "whyThisMatters": "This reduces type safety precisely where the upstream schema is known and stable enough to model, and it makes it harder to correctly support covers/guest artists in the future."
    },
    {
      "severity": "MEDIUM",
      "number": 7,
      "title": "`SetlistFmVenue.city` shape is heavily truncated vs docs (and `venue.id` is optional)",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "13-18",
      "category": "slop",
      "description": "Docs show `venue.city` containing fields like `id`, `state`, `stateCode`, `coords`, plus `country` as an object (not just `{ code }`). This type reduces city to `{ name; country?: { code } }` and makes both `venue.id` and `city` optional. Even if the app doesn’t currently use these fields, this is presented as an API response type and re-exported publicly.",
      "code": "export interface SetlistFmVenue {\n  name: string;\n  id?: string;\n  city?: { name: string; country?: { code: string } };\n  url?: string;\n}",
      "whyThisMatters": "Downstream code may assume the real payload matches these definitions and lose access to documented fields without realizing they exist."
    },
    {
      "severity": "MEDIUM",
      "number": 8,
      "title": "`SetlistFmSet.song` is required in the type, but implementation treats it as optional/malformed",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "28-32",
      "category": "will-break",
      "description": "The type claims every set always has `song: SetlistFmSong[]`. In practice, the mapper treats `fmSet.song` as unknown and guards with `Array.isArray`. This mismatch means the TypeScript types do not reflect the runtime contract the code is written against.",
      "code": "export interface SetlistFmSet {\n  name?: string;\n  encore?: number;\n  song: SetlistFmSong[];\n}",
      "whyThisMatters": "When types don’t match runtime realities, developers are forced into repetitive runtime checks and casts, and it becomes unclear what the app actually expects."
    },
    {
      "severity": "MEDIUM",
      "number": 9,
      "title": "API proxy returns untyped `unknown` setlist bodies; core API types are not used at the boundary",
      "file": "apps/api/src/routes/setlist/proxy.ts",
      "lines": "6-8",
      "category": "will-break",
      "description": "The proxy response explicitly returns `body: unknown`. This ensures the client boundary has no structural guarantees, yet the web client later casts the JSON into `SetlistFmResponse`. The repo contains setlist.fm types, but they are not used to validate or type the body at the server boundary.",
      "code": "export type ProxyResponse =\n  | { body: unknown; status: number }\n  | { error: string; status: number };",
      "whyThisMatters": "This promotes a pattern where the client treats upstream JSON as typed without verification, increasing the risk of runtime shape mismatches (especially around `set` / `sets`)."
    },
    {
      "severity": "MEDIUM",
      "number": 10,
      "title": "setlist.fm fetcher result type is also `unknown`, reinforcing unsafe casts downstream",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "70-72",
      "category": "slop",
      "description": "`FetchSetlistResult` returns `{ ok: true; body: unknown }`. This is a second layer where the payload is intentionally untyped, despite the repo having a `SetlistFmResponse` interface. The app currently relies on client-side casting + best-effort mapper guards.",
      "code": "export type FetchSetlistResult =\n  | { ok: true; body: unknown }\n  | { ok: false; status: number; message: string };",
      "whyThisMatters": "It increases the probability that setlist.fm schema drift (or wrapper shapes like `sets.set`) will reach the client unnoticed."
    },
    {
      "severity": "MEDIUM",
      "number": 11,
      "title": "Web client casts proxy JSON to `SetlistFmResponse` without validation (type safety is illusory)",
      "file": "apps/web/src/features/setlist-import/SetlistImportView.tsx",
      "lines": "48-63",
      "category": "will-break",
      "description": "The client parses JSON and immediately treats it as `{ error?: string } | SetlistFmResponse`. Because the upstream body is `unknown`, this cast can easily be wrong. The mapper validates only a small subset of fields, so incorrect shapes can propagate into UI/matching as empty or malformed data rather than being rejected.",
      "code": "const res = await fetch(url, { signal });\nconst data = (await res.json()) as { error?: string } | SetlistFmResponse;\n\n// ...\n\nconst mapped = mapSetlistFmToSetlist(data as SetlistFmResponse);",
      "whyThisMatters": "Incorrect type assumptions at the network boundary are a common source of production-only failures (API changes, partial outages returning HTML, wrapper objects, etc.)."
    },
    {
      "severity": "MEDIUM",
      "number": 12,
      "title": "MusicKit `configure()` return type is overly broad and forces “duck-typing thenable” logic",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "9-12",
      "category": "slop",
      "description": "`MusicKitGlobal.configure()` is typed as `Promise<MusicKitInstance> | MusicKitInstance | void`, which is so broad that the code must check for a `.then` function at runtime (instead of relying on types). This is a symptom of guessy/inaccurate typings and makes it hard to reason about the real contract.",
      "code": "interface MusicKitGlobal {\n  configure(options: MusicKitConfigureOptions): Promise<MusicKitInstance> | MusicKitInstance | void;\n  getInstance(): MusicKitInstance;\n}",
      "whyThisMatters": "It weakens type guarantees and makes the integration fragile across MusicKit script updates."
    },
    {
      "severity": "MEDIUM",
      "number": 13,
      "title": "MusicKit API response typing is under-specified and can silently generate empty-string track names",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "187-200",
      "category": "will-break",
      "description": "`searchCatalog()` asserts a partial response shape and then maps `name` to `s.attributes?.name ?? \"\"`. This allows “tracks” with empty names to be considered valid matches, and it hides whether missing attributes are a genuine API issue vs a typing mismatch.",
      "code": "const data = (await music.music.api(path)) as {\n  results?: { songs?: { data?: Array<{ id: string; attributes?: { name?: string; artistName?: string } }> } };\n  errors?: Array<{ detail?: string; status?: string }>;\n};\n\nconst tracks: AppleMusicTrack[] = songs.map((s) => ({\n  id: s.id,\n  name: s.attributes?.name ?? \"\",\n  artistName: s.attributes?.artistName,\n}));",
      "whyThisMatters": "Silent coercion to `\"\"` makes downstream matching and UI behavior incorrect without clear error signals, and it obscures whether the underlying response shape is being handled correctly."
    },
    {
      "severity": "MEDIUM",
      "number": 14,
      "title": "Apple track shapes are duplicated across core and web (risk of drift and inconsistent optionality)",
      "file": "packages/core/src/matching/types.ts",
      "lines": "1-5",
      "category": "slop",
      "description": "Core defines `AppleTrack` with `artistName?: string`. Web defines `AppleMusicTrack` with the same fields and optionality (`apps/web/src/lib/musickit.ts:37-41`). These are parallel types representing the same concept, but they live in different packages and are not tied together.",
      "code": "export interface AppleTrack {\n  id: string;\n  name: string;\n  artistName?: string;\n}",
      "whyThisMatters": "Duplicate “same-shape” types are a common source of subtle bugs when one evolves (e.g., making `artistName` required, adding `url`, changing `id` semantics) and the other doesn’t."
    },
    {
      "severity": "MEDIUM",
      "number": 15,
      "title": "`DevTokenResponse` is duplicated (discriminated union in API vs “all-optional” shape in web)",
      "file": "apps/api/src/routes/apple/dev-token.ts",
      "lines": "3-3",
      "category": "slop",
      "description": "The API exports a discriminated-by-property union (`{ token } | { error }`). The web client does not import this type and instead uses a weaker `{ token?: string; error?: string }` shape (`apps/web/src/lib/musickit.ts:58-66`). This loses the guarantee that a successful response contains a token and that an error response cannot contain a token.",
      "code": "export type DevTokenResponse = { token: string } | { error: string };",
      "whyThisMatters": "Type drift here can cause subtle runtime failures (e.g., server returning a malformed payload that still type-checks client-side), and it weakens the safety of the token-fetch path."
    },
    {
      "severity": "LOW",
      "number": 16,
      "title": "Placeholder types are exported publicly but unused, and do not represent stable API contracts",
      "file": "packages/core/src/apple/types.ts",
      "lines": "1-8",
      "category": "dead-end",
      "description": "`AppleCatalogTrack` is explicitly labeled “Placeholder” and is exported from `@repo/core` (`packages/core/src/apple/index.ts:1`) but is not used anywhere in the repo. Its fields are also highly optional (`attributes?.name?`, `attributes?.artistName?`) even though catalog track resources typically have stable required attributes. Similarly, `AppleTrack`/`MatchResult` are exported but unused (see `packages/core/src/matching/index.ts:1`).",
      "code": "/** Placeholder for Apple Music API types used by core (e.g. catalog track). */\nexport interface AppleCatalogTrack {\n  id: string;\n  attributes?: {\n    name?: string;\n    artistName?: string;\n  };\n}",
      "whyThisMatters": "Exported-but-unused placeholder types increase public surface area and can mislead future code into depending on incomplete or incorrect contracts."
    }
  ],
  "auditId": "11-types",
  "sourceFile": "11-types.md"
}