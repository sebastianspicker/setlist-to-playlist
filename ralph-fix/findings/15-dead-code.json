{
  "auditTitle": "Dead Code & Unused Files",
  "auditDate": "2026-02-14T11:51:42Z",
  "filesExamined": 41,
  "totalFindings": 18,
  "summary": {
    "critical": 0,
    "high": 0,
    "medium": 2,
    "low": 16
  },
  "findings": [
    {
      "severity": "LOW",
      "number": 1,
      "title": "Unused imports `authorizeMusicKit` and `initMusicKit`",
      "file": "apps/web/src/features/playlist-export/CreatePlaylistView.tsx",
      "lines": "6-12",
      "category": "slop",
      "description": "`authorizeMusicKit` and `initMusicKit` are imported but never referenced in this module.",
      "code": "import {\n  isMusicKitAuthorized,\n  authorizeMusicKit,\n  initMusicKit,\n  createLibraryPlaylist,\n  addTracksToLibraryPlaylist,\n} from \"@/lib/musickit\";",
      "whyThisMatters": "Unused imports add noise, can confuse readers about control flow, and can cause lint failures depending on configuration."
    },
    {
      "severity": "LOW",
      "number": 2,
      "title": "Unreachable fallback branch in `buildPlaylistName()`",
      "file": "apps/web/src/features/playlist-export/CreatePlaylistView.tsx",
      "lines": "20-25",
      "category": "dead-end",
      "description": "`parts` always contains the constant `\"Setlist\"` (a non-empty string), so `parts.length > 0` is always true and the fallback `\"Setlist\"` branch is dead code.",
      "code": "const parts = [\"Setlist\", setlist.artist, setlist.eventDate].filter(\n  (p) => p != null && String(p).trim() !== \"\"\n);\nreturn parts.length > 0 ? parts.join(\" – \") : \"Setlist\";",
      "whyThisMatters": "Dead branches make intent harder to reason about and can hide real edge-case handling needs."
    },
    {
      "severity": "LOW",
      "number": 3,
      "title": "Redundant `setLoading(false)` due to `finally` always executing",
      "file": "apps/web/src/features/playlist-export/CreatePlaylistView.tsx",
      "lines": "43-48, 68-70",
      "category": "dead-end",
      "description": "When the user is not authorized, the code sets `setLoading(false)` and returns from inside `try`, but `finally` will still run and set loading false again. The explicit `setLoading(false)` before returning is redundant.",
      "code": "if (!authorized) {\n  setNeedsAuth(true);\n  setLoading(false);\n  return;\n}\n...\n} finally {\n  setLoading(false);\n}",
      "whyThisMatters": "Redundant state updates add noise and can complicate future refactors (especially when state transitions become more complex)."
    },
    {
      "severity": "LOW",
      "number": 4,
      "title": "Redundant conditional assigning `status` (both branches identical)",
      "file": "apps/web/src/app/api/setlist/proxy/route.ts",
      "lines": "22-25",
      "category": "dead-end",
      "description": "The conditional expression assigns `result.status` in both branches, so the `\"error\" in result` check is dead logic here.",
      "code": "const result = await handleSetlistProxy(id);\nconst status = \"error\" in result ? result.status : result.status;\nconst body = \"error\" in result ? { error: result.error } : result.body;",
      "whyThisMatters": "Dead conditionals reduce clarity and can mislead readers into thinking there are different status behaviors for success vs error."
    },
    {
      "severity": "LOW",
      "number": 5,
      "title": "`apiUrl()` and `healthUrl()` are exported but unused in the repo",
      "file": "apps/web/src/lib/api.ts",
      "lines": "12-19, 24",
      "category": "dead-end",
      "description": "`apiUrl()` is exported but has no in-repo import sites; `healthUrl()` is also exported but appears unused (no call sites found).",
      "code": "export function apiUrl(path: string): string {\n  const raw = API_BASE_URL || \"\";\n  const base = raw.replace(/\\/$/, \"\").replace(/\\/api$/i, \"\");\n  const p = path.startsWith(\"/\") ? path : `/${path}`;\n  const apiSegment = \"/api\";\n  if (base) return `${base}${apiSegment}${p}`;\n  return `${API_PATH}${p}`;\n}\n\nexport const healthUrl = () => apiUrl(\"/health\");",
      "whyThisMatters": "Unused exports widen the module’s public surface area, making the codebase harder to maintain and audit."
    },
    {
      "severity": "LOW",
      "number": 6,
      "title": "`getAllowOrigin()` is exported but unused outside this module",
      "file": "apps/web/src/lib/cors.ts",
      "lines": "7-17",
      "category": "dead-end",
      "description": "`getAllowOrigin()` is exported, but there are no in-repo imports of it; only `corsHeaders()` is imported by API route handlers.",
      "code": "export function getAllowOrigin(origin: string | null): string | null {\n  const configured = (process.env.ALLOWED_ORIGIN ?? \"\").trim();\n  const isLocalOrigin =\n    origin &&\n    (origin.startsWith(\"http://localhost\") || origin.startsWith(\"http://127.0.0.1\"));\n  if (configured) {\n    const single = configured.split(\",\")[0].trim();\n    return single || (isLocalOrigin ? origin : null);\n  }\n  return isLocalOrigin ? origin : null;\n}",
      "whyThisMatters": "Unused exports suggest either incomplete test coverage/consumers or leftover API surface that increases maintenance burden."
    },
    {
      "severity": "LOW",
      "number": 7,
      "title": "Multiple exported symbols in `musickit.ts` appear unused outside the module",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "53-70, 125-128, 205-208",
      "category": "dead-end",
      "description": "These exports have no in-repo import sites:\n- `fetchDeveloperToken()` (used internally by `initMusicKit`)\n- `getMusicKitInstance()`\n- `CreatePlaylistResult` (named exported interface, but callers only use `createLibraryPlaylist()`)",
      "code": "export async function fetchDeveloperToken(): Promise<string> { /* ... */ }\n\nexport function getMusicKitInstance(): MusicKitInstance {\n  if (!configuredInstance) throw new Error(\"MusicKit not configured. Call initMusicKit() first.\");\n  return configuredInstance;\n}\n\nexport interface CreatePlaylistResult {\n  id: string;\n  url?: string;\n}",
      "whyThisMatters": "Unused exports enlarge public API surface area and can encourage inconsistent usage patterns (multiple “ways” to do the same thing)."
    },
    {
      "severity": "LOW",
      "number": 8,
      "title": "`SetlistPreview` is re-exported from the feature barrel but not used via the barrel",
      "file": "apps/web/src/features/setlist-import/index.ts",
      "lines": "1-2",
      "category": "dead-end",
      "description": "`SetlistPreview` is re-exported, but the only usage imports it directly from `./SetlistPreview` (and no other module imports it from the feature index).",
      "code": "export { SetlistImportView } from \"./SetlistImportView\";\nexport { SetlistPreview } from \"./SetlistPreview\";",
      "whyThisMatters": "Unused re-exports create the impression of a supported public API that the codebase doesn’t actually rely on."
    },
    {
      "severity": "LOW",
      "number": 9,
      "title": "`DevTokenResponse` and `ProxyResponse` are re-exported from the `api` entrypoint but unused in the repo",
      "file": "apps/api/src/index.ts",
      "lines": "1-5",
      "category": "dead-end",
      "description": "The `api` package entrypoint re-exports `DevTokenResponse` and `ProxyResponse`, but there are no import sites for these types in the repo.",
      "code": "export { handleDevToken } from \"./routes/apple/dev-token.js\";\nexport type { DevTokenResponse } from \"./routes/apple/dev-token.js\";\nexport { handleHealth } from \"./routes/health.js\";\nexport { handleSetlistProxy } from \"./routes/setlist/proxy.js\";\nexport type { ProxyResponse } from \"./routes/setlist/proxy.js\";",
      "whyThisMatters": "Unused exported types inflate the public API surface and can mislead readers about intended consumers."
    },
    {
      "severity": "LOW",
      "number": 10,
      "title": "`FetchSetlistResult` is exported but unused outside `setlistfm.ts`",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "70-72",
      "category": "dead-end",
      "description": "`FetchSetlistResult` is exported but has no in-repo imports. It is only used as the return type of `fetchSetlistFromApi()` within the same module.",
      "code": "export type FetchSetlistResult =\n  | { ok: true; body: unknown }\n  | { ok: false; status: number; message: string };",
      "whyThisMatters": "Unused exports add API surface without providing actual reuse in the codebase."
    },
    {
      "severity": "MEDIUM",
      "number": 11,
      "title": "Entire `core/apple` export surface appears unused (placeholder module)",
      "file": "packages/core/src/apple/index.ts",
      "lines": "1",
      "category": "dead-end",
      "description": "`@repo/core` re-exports `AppleCatalogTrack` via `packages/core/src/apple/index.ts`, but there are no imports/usages of this type in the repository (outside audit/docs). This makes `core/apple` effectively orphaned as a public module.",
      "code": "export type { AppleCatalogTrack } from './types.js';",
      "whyThisMatters": "An unused “placeholder” public module can confuse maintainers about supported domain concepts and increases long-term maintenance surface."
    },
    {
      "severity": "MEDIUM",
      "number": 12,
      "title": "Exported matching result types appear unused across the repo",
      "file": "packages/core/src/matching/types.ts",
      "lines": "1-12",
      "category": "dead-end",
      "description": "`AppleTrack` and `MatchResult` are exported (and re-exported through `packages/core/src/matching/index.ts`), but there are no in-repo consumers importing them. The web app defines and uses its own parallel type (`AppleMusicTrack`) instead.",
      "code": "export interface AppleTrack {\n  id: string;\n  name: string;\n  artistName?: string;\n}\n\nexport interface MatchResult {\n  setlistEntry: { name: string; artist?: string };\n  appleTrack: AppleTrack | null;\n}",
      "whyThisMatters": "Unused “domain” types strongly suggest abandoned or unfinished abstractions and can mislead readers about where matching logic/results are modeled."
    },
    {
      "severity": "LOW",
      "number": 13,
      "title": "Several setlist.fm types are re-exported but unused in the repo",
      "file": "packages/core/src/setlist/index.ts",
      "lines": "2-8",
      "category": "dead-end",
      "description": "`SetlistFmArtist`, `SetlistFmVenue`, `SetlistFmSong`, and `SetlistFmSet` are re-exported, but no code in the repo imports these symbols directly (outside audit/docs). Only `SetlistFmResponse` is imported in the web app.",
      "code": "export type {\n  SetlistFmResponse,\n  SetlistFmArtist,\n  SetlistFmVenue,\n  SetlistFmSong,\n  SetlistFmSet,\n} from \"./setlistfm-types.js\";",
      "whyThisMatters": "Unused re-exports expand API surface and add maintenance overhead (more “public” types to keep consistent with real responses)."
    },
    {
      "severity": "LOW",
      "number": 14,
      "title": "Orphan placeholder file (empty `.gitkeep`) in API middleware directory",
      "file": "apps/api/src/middleware/.gitkeep",
      "lines": "(empty file)",
      "category": "dead-end",
      "description": "The middleware directory contains only an empty `.gitkeep` and no implementation files in scope.",
      "code": "// empty file",
      "whyThisMatters": "Empty placeholder files/directories can indicate abandoned scaffolding and make it harder to tell what infrastructure is actually in use."
    },
    {
      "severity": "LOW",
      "number": 15,
      "title": "Orphan placeholder file (empty `.gitkeep`) for `components/`",
      "file": "apps/web/src/components/.gitkeep",
      "lines": "(empty file)",
      "category": "dead-end",
      "description": "`apps/web/src/components/` is empty aside from `.gitkeep`.",
      "code": "// empty file",
      "whyThisMatters": "Empty placeholder directories can be mistaken for active architecture and increase “where should this go?” ambiguity."
    },
    {
      "severity": "LOW",
      "number": 16,
      "title": "Orphan placeholder file (empty `.gitkeep`) in `lib/`",
      "file": "apps/web/src/lib/.gitkeep",
      "lines": "(empty file)",
      "category": "dead-end",
      "description": "`apps/web/src/lib/` includes an empty `.gitkeep` even though the directory already contains real code files.",
      "code": "// empty file",
      "whyThisMatters": "Redundant placeholders add clutter and can complicate future cleanups or tooling that treats dotfiles specially."
    },
    {
      "severity": "LOW",
      "number": 17,
      "title": "Orphan placeholder file (empty `.gitkeep`) for `types/`",
      "file": "apps/web/src/types/.gitkeep",
      "lines": "(empty file)",
      "category": "dead-end",
      "description": "`apps/web/src/types/` is empty aside from `.gitkeep` and has no in-scope imports referencing this directory.",
      "code": "// empty file",
      "whyThisMatters": "An unused types directory can lead to duplicated or ad-hoc typing elsewhere, since the “intended place” exists but is not used."
    },
    {
      "severity": "LOW",
      "number": 18,
      "title": "Exported component props interfaces appear unused outside their defining modules",
      "file": "apps/web/src/features/matching/ConnectAppleMusic.tsx",
      "lines": "6-9",
      "category": "dead-end",
      "description": "Several props interfaces are exported but have no in-repo import sites:\n- `ConnectAppleMusicProps` (`ConnectAppleMusic.tsx`)\n- `MatchingViewProps` (`MatchingView.tsx`)\n- `CreatePlaylistViewProps` (`CreatePlaylistView.tsx`)",
      "code": "export interface ConnectAppleMusicProps {\n  onAuthorized?: () => void;\n  label?: string;\n}",
      "whyThisMatters": "Exporting types that aren’t consumed elsewhere increases public API surface area and can imply supported reuse patterns that don’t exist in practice."
    }
  ],
  "auditId": "15-dead-code",
  "sourceFile": "15-dead-code.md"
}