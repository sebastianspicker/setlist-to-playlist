{
  "auditTitle": "Config, Environment & CORS",
  "auditDate": "2026-02-15",
  "filesExamined": 25,
  "totalFindings": 14,
  "summary": {
    "critical": 1,
    "high": 1,
    "medium": 6,
    "low": 6
  },
  "findings": [
    {
      "severity": "CRITICAL",
      "number": 1,
      "title": "“Localhost” origin check can allow non-local attacker origins when `ALLOWED_ORIGIN` is unset",
      "file": "apps/web/src/lib/cors.ts",
      "lines": "8-18",
      "category": "broken-logic",
      "description": "`getAllowOrigin()` treats any `Origin` that *starts with* `http://localhost` or `http://127.0.0.1` as “local” and returns it when `ALLOWED_ORIGIN` is unset. Because this is a string-prefix check (not a hostname check), it also matches attacker-controlled domains like `http://localhost.evil.com` (and similar prefix tricks). In that misconfigured state (unset `ALLOWED_ORIGIN`), the API routes using `corsHeaders()` will emit `Access-Control-Allow-Origin` for an attacker origin, enabling browser JS on that attacker site to read responses.",
      "code": "export function getAllowOrigin(origin: string | null): string | null {\n  const configured = (process.env.ALLOWED_ORIGIN ?? \"\").trim();\n  const isLocalOrigin =\n    origin &&\n    (origin.startsWith(\"http://localhost\") || origin.startsWith(\"http://127.0.0.1\"));\n  if (configured) {\n    const single = configured.split(\",\")[0].trim().replace(/\\/$/, \"\");\n    return single || (isLocalOrigin ? origin : null);\n  }\n  return isLocalOrigin ? origin : null;\n}",
      "whyThisMatters": "If `ALLOWED_ORIGIN` is forgotten/missing in a deployment where the dev-token/proxy endpoints are reachable cross-origin, this becomes a credential/data exposure path (Developer Token and setlist proxy responses become readable from attacker origins)."
    },
    {
      "severity": "HIGH",
      "number": 2,
      "title": "`NEXT_PUBLIC_APPLE_MUSIC_APP_ID` can pass “required” validation but still be used with invalid whitespace",
      "file": "apps/web/src/lib/config.ts",
      "lines": "18-20",
      "category": "will-break",
      "description": "`APPLE_MUSIC_APP_ID` is exported as-is (no trimming/normalization). Downstream, `initMusicKit()` checks `APPLE_MUSIC_APP_ID.trim() === \"\"` to detect blank config, but then calls `MusicKit.configure` with the **untrimmed** value. A value like `\" my-app-id \"` passes the “required” check yet is still used with whitespace.",
      "code": "export const APPLE_MUSIC_APP_ID =\n  process.env.NEXT_PUBLIC_APPLE_MUSIC_APP_ID ?? \"\";",
      "whyThisMatters": "This creates a configuration “gotcha” where production can break despite appearing configured, and failures will look like downstream MusicKit issues rather than a simple env formatting issue."
    },
    {
      "severity": "MEDIUM",
      "number": 3,
      "title": "Trailing-slash normalization is incomplete; multiple trailing slashes can produce malformed API URLs (including `//api` and `/api//api`)",
      "file": "apps/web/src/lib/config.ts",
      "lines": "12-16",
      "category": "will-break",
      "description": "`API_BASE_URL` only strips **one** trailing `/` via `.replace(/\\/$/, \"\")`. If `NEXT_PUBLIC_API_URL` ends with multiple slashes (common copy/paste), it can leave `API_BASE_URL` with trailing `//`, which then interacts badly with `apiUrl()`’s `/api` stripping and concatenation.",
      "code": "export const API_BASE_URL: string =\n  typeof process.env.NEXT_PUBLIC_API_URL === \"string\" &&\n  process.env.NEXT_PUBLIC_API_URL.trim().length > 0\n    ? process.env.NEXT_PUBLIC_API_URL.trim().replace(/\\/$/, \"\")\n    : \"\";",
      "whyThisMatters": "Operators can set `NEXT_PUBLIC_API_URL=https://example.com/api///` and end up with URLs like `https://example.com/api//api/...`, which can break requests and be very difficult to diagnose (especially when only some environments have “extra slash” values)."
    },
    {
      "severity": "MEDIUM",
      "number": 4,
      "title": "`apiUrl()` always forces an `/api` segment; any non-standard base path produces surprising URLs",
      "file": "apps/web/src/lib/api.ts",
      "lines": "12-18",
      "category": "will-break",
      "description": "When `API_BASE_URL` is set, `apiUrl()` always appends `\"/api\"` (via `apiSegment`) after optionally stripping a trailing `/api`. If a deployment mounts the API under a different path (e.g. `/api/v1`) or expects root-mounted endpoints, the helper will still generate `.../api/...`.",
      "code": "const base = raw.replace(/\\/$/, \"\").replace(/\\/api$/i, \"\");\nconst apiSegment = \"/api\";\nif (base) return `${base}${apiSegment}${p}`;\nreturn `${API_PATH}${p}`;",
      "whyThisMatters": "This is a sharp edge in configuration: the env var name (`NEXT_PUBLIC_API_URL`) implies “base URL”, but the helper’s behavior implies “origin (optionally with `/api`)”. Misalignment can lead to hard-to-debug 404s (wrong constructed URL)."
    },
    {
      "severity": "MEDIUM",
      "number": 5,
      "title": "`ALLOWED_ORIGIN` accepts invalid/ambiguous values (paths, multiple origins) and only partially normalizes trailing slashes",
      "file": "apps/web/src/lib/cors.ts",
      "lines": "9-16",
      "category": "will-break",
      "description": "- The implementation takes only the first comma-separated origin (`split(\",\")[0]`) and silently ignores additional entries.\n- It removes only a single trailing slash (`replace(/\\/$/, \"\")`), so values with multiple trailing slashes remain malformed.\n- It does not guard against `ALLOWED_ORIGIN` including a path (e.g. `https://app.example.com/some/path`), which is not a valid `Access-Control-Allow-Origin` value.",
      "code": "const configured = (process.env.ALLOWED_ORIGIN ?? \"\").trim();\n...\nconst single = configured.split(\",\")[0].trim().replace(/\\/$/, \"\");\nreturn single || (isLocalOrigin ? origin : null);",
      "whyThisMatters": "CORS configuration errors typically manifest as opaque “CORS error” in browsers; these normalization gaps increase the chance that “looks correct” env values fail at runtime."
    },
    {
      "severity": "MEDIUM",
      "number": 6,
      "title": "CORS headers vary by request `Origin` but responses do not emit `Vary: Origin`",
      "file": "apps/web/src/lib/cors.ts",
      "lines": "20-28",
      "category": "will-break",
      "description": "When `ALLOWED_ORIGIN` is unset, `getAllowOrigin()` may echo back the request’s `Origin`. That means the response varies by `Origin`, but the headers do not include `Vary: Origin`. Intermediary caching (CDNs/proxies) can cache a response and serve it with a mismatched `Access-Control-Allow-Origin` behavior.",
      "code": "export function corsHeaders(request: NextRequest, contentType = \"application/json\"): HeadersInit {\n  const origin = request.headers.get(\"origin\");\n  const allowOrigin = getAllowOrigin(origin);\n  const headers: HeadersInit = { \"Content-Type\": contentType };\n  if (allowOrigin) {\n    (headers as Record<string, string>)[\"Access-Control-Allow-Origin\"] = allowOrigin;\n  }\n  return headers;\n}",
      "whyThisMatters": "Caching/CORS interactions are a common source of production-only failures and confusing security postures (the wrong origin may appear “allowed” or “blocked” depending on cache state)."
    },
    {
      "severity": "LOW",
      "number": 7,
      "title": "“Local origin” logic excludes `https://localhost` (dev environments using HTTPS will fail unless `ALLOWED_ORIGIN` is set)",
      "file": "apps/web/src/lib/cors.ts",
      "lines": "10-12",
      "category": "will-break",
      "description": "The “local” fallback only recognizes `http://localhost…` and `http://127.0.0.1…`. It does not recognize `https://localhost…` or `https://127.0.0.1…`.",
      "code": "const isLocalOrigin =\n  origin &&\n  (origin.startsWith(\"http://localhost\") || origin.startsWith(\"http://127.0.0.1\"));",
      "whyThisMatters": "Developers using HTTPS locally (or tools that serve HTTPS by default) can get unexpected CORS failures in dev/test setups."
    },
    {
      "severity": "LOW",
      "number": 8,
      "title": "`.env.example` CORS guidance is incomplete and slightly inaccurate",
      "file": ".env.example",
      "lines": "18-19",
      "category": "slop",
      "description": "- The guidance says “only http://localhost is allowed” when unset, but the code also allows `http://127.0.0.1…` and has more nuanced behavior.\n- `ALLOWED_ORIGIN` is only shown as a commented example (no placeholder assignment line), which increases the chance it is missed.",
      "code": "# CORS: required in production. When unset, only http://localhost is allowed (DCI-001).\n# ALLOWED_ORIGIN=https://your-app.example.com",
      "whyThisMatters": "CORS misconfiguration frequently looks like an application outage from the browser perspective; incomplete examples increase operational risk."
    },
    {
      "severity": "MEDIUM",
      "number": 9,
      "title": "Apple Music docs list a dev-token endpoint path that does not match the implemented Next.js route",
      "file": "docs/tech/apple-music.md",
      "lines": "19-22",
      "category": "slop",
      "description": "The docs state `GET /apple/dev-token (or equivalent)` but the current implemented route is `GET /api/apple/dev-token` (`apps/web/src/app/api/apple/dev-token/route.ts:9-23`). This ambiguity is directly relevant to `NEXT_PUBLIC_API_URL` usage and reverse-proxy / monitoring configuration.",
      "code": "## Endpoints (our side)\n\n- `GET /apple/dev-token` (or equivalent): Returns `{ token: \"…\" }` ...",
      "whyThisMatters": "Operators may configure base URLs, proxy rewrites, or uptime checks against the wrong path, leading to “works locally” but fails in deployment."
    },
    {
      "severity": "MEDIUM",
      "number": 10,
      "title": "`docs/code-inspection-findings.md` contains high-impact stale/contradictory CORS claims",
      "file": "docs/code-inspection-findings.md",
      "lines": "33-60",
      "category": "slop",
      "description": "The document simultaneously claims:\n- In the top “Fixes applied” table that only `http://localhost*` is allowed when `ALLOWED_ORIGIN` is unset (line 15), **and**\n- In the summary + detailed section that CORS allows **any HTTPS origin** when `ALLOWED_ORIGIN` is unset (lines 33 and 55-60), including a code snippet that no longer matches the current implementation.",
      "code": "| DCI-001  | P0       | §2 API Token   | CORS allows any HTTPS origin when `ALLOWED_ORIGIN` unset |\n\n### DCI-001 — CORS allows any HTTPS origin when `ALLOWED_ORIGIN` is unset [P0]\n- **What:** `allowOrigin` is set to `ALLOWED_ORIGIN || ... origin.startsWith(\"https://\") ...`",
      "whyThisMatters": "This is security-relevant documentation. Stale claims can cause incorrect risk assessments, incorrect incident response, and misinformed changes to CORS configuration."
    },
    {
      "severity": "MEDIUM",
      "number": 11,
      "title": "Multiple “completed plan” docs still describe a different CORS fallback behavior (“localhost/https”)",
      "file": "docs/exec-plans/completed/002-api-dev-token.md",
      "lines": "7-12",
      "category": "slop",
      "description": "The dev-token completion notes claim dev fallback allows “localhost/https”, which does not match the current `apps/web/src/lib/cors.ts` logic (http-only localhost/127.0.0.1 checks).",
      "code": "- **T009** – CORS on dev-token route: `Access-Control-Allow-Origin` from `ALLOWED_ORIGIN` or, in dev, request origin when localhost/https.",
      "whyThisMatters": "These docs are likely referenced for environment setup. When they disagree with code, they increase the odds of broken deployments or incorrect assumptions about what’s allowed cross-origin."
    },
    {
      "severity": "LOW",
      "number": 12,
      "title": "`NEXT_PUBLIC_*` values are build-time substituted in the client; docs/UX may implicitly suggest runtime configurability",
      "file": "apps/web/src/lib/config.ts",
      "lines": "12-16",
      "category": "will-break",
      "description": "The web app config reads `process.env.NEXT_PUBLIC_*` in a module export. In Next.js, `NEXT_PUBLIC_*` values used in client bundles are typically inlined at build time. If operators expect to change `NEXT_PUBLIC_API_URL` / `NEXT_PUBLIC_APPLE_MUSIC_APP_ID` without rebuilding/redeploying, the running client may keep using old values.",
      "code": "export const API_BASE_URL: string =\n  typeof process.env.NEXT_PUBLIC_API_URL === \"string\" &&\n  process.env.NEXT_PUBLIC_API_URL.trim().length > 0\n    ? process.env.NEXT_PUBLIC_API_URL.trim().replace(/\\/$/, \"\")\n    : \"\";",
      "whyThisMatters": "Misunderstanding env lifecycle can lead to “we changed the env var but nothing changed” incidents, especially during cutovers between same-origin and separate API setups."
    },
    {
      "severity": "LOW",
      "number": 13,
      "title": "Preflight `Access-Control-Allow-Headers` is hard-coded to `Content-Type` only",
      "file": "apps/web/src/lib/cors.ts",
      "lines": "33-42",
      "category": "will-break",
      "description": "`corsHeadersForOptions()` only allows `Content-Type`. If future browser requests include non-simple headers (e.g. `Authorization`) or other requested headers, preflight can fail.",
      "code": "headers[\"Access-Control-Allow-Methods\"] = \"GET, OPTIONS\";\nheaders[\"Access-Control-Allow-Headers\"] = \"Content-Type\";",
      "whyThisMatters": "This is a latent integration hazard: CORS may appear fine today (GET-only, simple requests) but break when request shapes evolve."
    },
    {
      "severity": "LOW",
      "number": 14,
      "title": "Dev-token error responses omit the explicit no-cache headers applied on success",
      "file": "apps/web/src/app/api/apple/dev-token/route.ts",
      "lines": "9-23",
      "category": "will-break",
      "description": "On the success path, the handler sets `Cache-Control: no-store` and `Pragma: no-cache`. On the exception path, it returns a 500 with `corsHeaders(request)` only (no explicit cache headers). Depending on intermediaries, error responses could be cached differently than intended.",
      "code": "try {\n  ...\n  headers[\"Cache-Control\"] = \"no-store\";\n  headers[\"Pragma\"] = \"no-cache\";\n  return new Response(JSON.stringify(result), { status, headers });\n} catch {\n  const headers = corsHeaders(request) as Record<string, string>;\n  return new Response(\n    JSON.stringify({ error: \"An unexpected error occurred. Please try again.\" }),\n    { status: 500, headers }\n  );\n}",
      "whyThisMatters": "Inconsistent caching behavior around sensitive endpoints increases operational confusion and can worsen incident recovery (clients seeing cached failures)."
    }
  ],
  "auditId": "09-config-cors",
  "sourceFile": "09-config-cors.md"
}