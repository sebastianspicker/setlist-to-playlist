{
  "auditTitle": "setlist.fm Proxy Deep Audit",
  "auditDate": "2026-02-15",
  "filesExamined": 4,
  "totalFindings": 11,
  "summary": {
    "critical": 0,
    "high": 3,
    "medium": 6,
    "low": 2
  },
  "findings": [
    {
      "severity": "HIGH",
      "number": 1,
      "title": "Public proxy can be abused to drain `SETLISTFM_API_KEY` quota (CORS is not access control)",
      "file": "apps/web/src/app/api/setlist/proxy/route.ts",
      "lines": "11-44",
      "category": "will-break",
      "description": "This is a public, unauthenticated GET endpoint that triggers server-side calls to setlist.fm using the server’s `SETLISTFM_API_KEY` (via `handleSetlistProxy`). The only “restriction” visible here is CORS response headers, but CORS only affects whether browser JavaScript can read the response. Any non-browser client (curl, bots, server-to-server) can call this endpoint directly and force upstream requests, consuming rate limits/quota and potentially causing service degradation.",
      "code": "export async function GET(request: NextRequest) {\n  const id = request.nextUrl.searchParams.get(\"id\") ?? request.nextUrl.searchParams.get(\"url\") ?? \"\";\n  // ...\n  const result = await handleSetlistProxy(id);\n  // ...\n  return new Response(JSON.stringify(body), { status, headers: corsHeaders(request) });\n}",
      "whyThisMatters": "Even if browser cross-origin reads are blocked, the server still performs the upstream call. This enables trivial automated abuse that burns the API key’s allowance and can cascade into 429s and user-visible failures."
    },
    {
      "severity": "HIGH",
      "number": 2,
      "title": "Upstream fetch has no timeout/abort; requests can hang and tie up server resources",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "92-125",
      "category": "will-break",
      "description": "`fetchSetlistFromApi` calls `fetch()` without any timeout/abort. Network stalls (DNS issues, upstream hangs, partial connectivity) can lead to long-running requests. Because this runs in an API route path, hung upstream calls can accumulate under load, consuming runtime resources and causing cascading latency/failures.",
      "code": "for (let attempt = 0; attempt <= MAX_RETRIES_429; attempt++) {\n  const res = await fetch(url, { headers });\n  // ...\n}",
      "whyThisMatters": "In production, transient upstream/network issues are normal. Without a bounded request time, the proxy can become a bottleneck and amplify outages."
    },
    {
      "severity": "HIGH",
      "number": 3,
      "title": "“Cache eviction threshold” does not cap cache size; memory can grow unbounded within TTL window",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "38-67",
      "category": "will-break",
      "description": "The cache only evicts *expired* entries when `cache.size > CACHE_EVICT_THRESHOLD`. If an attacker (or heavy usage) requests many unique setlist IDs within the 1-hour TTL, none expire, so `evictExpired()` deletes nothing and the `Map` continues growing without bound. The threshold reduces eviction frequency but does not enforce a maximum size.",
      "code": "const CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour\nconst cache = new Map<string, { body: unknown; expires: number }>();\n\nconst CACHE_EVICT_THRESHOLD = 200;\n\nfunction setCached(id: string, body: unknown): void {\n  cache.set(id, { body, expires: Date.now() + CACHE_TTL_MS });\n  if (cache.size > CACHE_EVICT_THRESHOLD) {\n    evictExpired();\n  }\n}",
      "whyThisMatters": "A simple high-cardinality request pattern can cause steady memory growth, leading to process instability or crashes."
    },
    {
      "severity": "MEDIUM",
      "number": 4,
      "title": "Host validation contradicts comment; `includes(\"setlist.fm\")` accepts lookalike domains",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "15-16",
      "category": "broken-logic",
      "description": "The comment says “only accept URLs whose host is setlist.fm”, but the implementation uses substring matching on hostname. This accepts hosts like `evilsetlist.fm` or `setlist.fm.evil.com`, which are not setlist.fm.",
      "code": "// only accept URLs whose host is setlist.fm ...\nif (!url.hostname.toLowerCase().includes(\"setlist.fm\")) return null;",
      "whyThisMatters": "This is a correctness/security footgun: the parser claims to enforce strict host checks but does not. Even though the current code only extracts an ID (and later fetches a fixed setlist.fm API base), the mismatch invites future unsafe reuse and can accept misleading inputs."
    },
    {
      "severity": "MEDIUM",
      "number": 5,
      "title": "Setlist ID validation is inconsistent and overly permissive (e.g., accepts all-hyphen “IDs”)",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "18-35",
      "category": "broken-logic",
      "description": "The parser uses multiple, inconsistent acceptance rules:\n- URL regex accepts 4–12 hex chars (`[a-f0-9]{4,12}`).\n- Raw ID accepts 4–64 chars of `[a-f0-9-]`, which includes values like `\"----\"` (no hex digits at all).\n- A fallback returns `withoutHtml` if it matches `^[a-f0-9-]+$` with no length constraints, potentially returning nonsense.\n\nThese rules can produce false positives (treat invalid input as an ID), resulting in confusing downstream errors and extra upstream calls.",
      "code": "const match = path.match(/-([a-f0-9]{4,12})\\.html$/i);\n// ...\nif (withoutHtml && /^[a-f0-9-]+$/i.test(withoutHtml)) return withoutHtml;\n// ...\nif (/^[a-f0-9-]{4,64}$/i.test(trimmed)) return trimmed;",
      "whyThisMatters": "Loose parsing increases unexpected 404s/429s and makes it harder to reason about input validity and error reporting."
    },
    {
      "severity": "MEDIUM",
      "number": 6,
      "title": "Upstream error message forwarding can leak raw upstream content (JSON/HTML) to clients",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "111-117",
      "category": "will-break",
      "description": "On non-OK responses, the code reads the entire response body as text and tries to parse JSON. If parsing succeeds but the JSON does not have a top-level `message`, it falls back to `text`, which is the full response payload. That payload then becomes `result.message` and is returned to clients (truncated later, but still raw upstream content).",
      "code": "const text = await res.text();\ntry {\n  const json = JSON.parse(text) as { message?: string };\n  lastMessage = json.message ?? (text || res.statusText);\n} catch {\n  lastMessage = text || res.statusText;\n}",
      "whyThisMatters": "This can expose upstream error formats/details directly to the frontend (including markup). If the frontend ever renders this unsafely, it can become an injection vector; even when rendered safely, it can leak implementation details and confuse users."
    },
    {
      "severity": "MEDIUM",
      "number": 7,
      "title": "Proxy forwards upstream error strings to clients with minimal sanitization",
      "file": "apps/api/src/routes/setlist/proxy.ts",
      "lines": "38-46",
      "category": "will-break",
      "description": "`handleSetlistProxy` truncates error strings to 500 chars but otherwise forwards upstream-derived messages. Combined with the upstream behavior in `fetchSetlistFromApi`, this means end users can receive arbitrary upstream text/JSON/HTML fragments.",
      "code": "const MAX_ERROR_MESSAGE_LENGTH = 500;\nconst message =\n  typeof result.message === \"string\" && result.message.length > MAX_ERROR_MESSAGE_LENGTH\n    ? result.message.slice(0, MAX_ERROR_MESSAGE_LENGTH) + \"…\"\n    : result.message;\n\nreturn { error: message, status };",
      "whyThisMatters": "Even truncated, returning raw upstream content is a common source of confusing UX and accidental information disclosure."
    },
    {
      "severity": "MEDIUM",
      "number": 8,
      "title": "No response-shape validation; `unknown` is passed through end-to-end",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "72-75, 96-109",
      "category": "will-break",
      "description": "Successful responses are typed as `unknown`, cached as `unknown`, and returned as-is. No runtime validation ensures the payload actually matches the expected setlist.fm “setlist” shape. If setlist.fm returns a partial payload, an error payload with 200 status, or an unexpected structure, downstream code may break or show incorrect data.",
      "code": "export type FetchSetlistResult =\n  | { ok: true; body: unknown }\n  | { ok: false; status: number; message: string };\n\n// ...\nbody = (await res.json()) as unknown;\nsetCached(setlistId, body);\nreturn { ok: true, body };",
      "whyThisMatters": "This makes the system fragile to upstream changes and unusual edge responses, and it can turn upstream anomalies into hard-to-debug client issues."
    },
    {
      "severity": "MEDIUM",
      "number": 9,
      "title": "429 handling is simplistic; no use of server guidance headers and no global throttling",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "69-133",
      "category": "will-break",
      "description": "The retry loop uses a fixed backoff schedule (1s, 2s) with a small retry count and does not consider any response headers that might guide retry timing (if present). It also retries per-request without any shared throttling, so concurrent bursts can repeatedly hit 429 and multiply load.",
      "code": "const MAX_RETRIES_429 = 2;\nconst BACKOFF_MS = 1000;\n\nif (res.status === 429 && attempt < MAX_RETRIES_429) {\n  await new Promise((r) => setTimeout(r, BACKOFF_MS * (attempt + 1)));\n  continue;\n}",
      "whyThisMatters": "Under bursty traffic, this approach can increase latency, waste retries, and amplify rate-limit lockouts."
    },
    {
      "severity": "MEDIUM",
      "number": 10,
      "title": "Cache can serve stale setlist data despite API being “current version”; no cache-bypass mechanism",
      "file": "apps/api/src/lib/setlistfm.ts",
      "lines": "38-48, 80-82",
      "category": "will-break",
      "description": "The implementation caches setlist responses for 1 hour and always serves cached results when present. The setlist.fm API endpoint explicitly returns the “current version” of a setlist (which can change if edited), but this proxy can serve up to 1 hour of stale data with no bypass/refresh path.",
      "code": "const CACHE_TTL_MS = 60 * 60 * 1000; // 1 hour\n\nconst cached = getCached(setlistId);\nif (cached !== null) return { ok: true, body: cached };",
      "whyThisMatters": "Users may see outdated setlist contents (tracks/ordering) after edits on setlist.fm, and the behavior will be inconsistent across instances (in-memory per process)."
    },
    {
      "severity": "LOW",
      "number": 11,
      "title": "Minor code slop / redundancy in route handler status assignment",
      "file": "apps/web/src/app/api/setlist/proxy/route.ts",
      "lines": "35-36",
      "category": "slop",
      "description": "The status computation is redundant and does not meaningfully branch; both sides return `result.status`. This looks like leftover code and adds noise to a security-sensitive route.",
      "code": "const status = \"error\" in result ? result.status : result.status;",
      "whyThisMatters": "Small, unnecessary redundancy increases maintenance burden and can hide real logic mistakes during future changes."
    },
    {
      "severity": "MEDIUM",
      "number": 12,
      "title": "Dynamic `Access-Control-Allow-Origin` without `Vary: Origin` can enable cache confusion",
      "file": "apps/web/src/lib/cors.ts",
      "lines": "20-27",
      "category": "will-break",
      "description": "When CORS is enabled, `Access-Control-Allow-Origin` is set dynamically based on environment/request origin. The response headers do not include `Vary: Origin`. If an intermediary cache/CDN ever caches these GET responses, it could incorrectly serve a response with a previously set `Access-Control-Allow-Origin` value to a different requesting origin.",
      "code": "export function corsHeaders(request: NextRequest, contentType = \"application/json\"): HeadersInit {\n  const origin = request.headers.get(\"origin\");\n  const allowOrigin = getAllowOrigin(origin);\n  const headers: HeadersInit = { \"Content-Type\": contentType };\n  if (allowOrigin) {\n    (headers as Record<string, string>)[\"Access-Control-Allow-Origin\"] = allowOrigin;\n  }\n  return headers;\n}",
      "whyThisMatters": "This is a classic subtle CORS + caching interaction that can produce inconsistent behavior and, in some configurations, weaken origin isolation."
    }
  ],
  "auditId": "03-setlist-proxy",
  "sourceFile": "03-setlist-proxy.md"
}