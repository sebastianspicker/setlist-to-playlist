{
  "auditTitle": "Playlist Export",
  "auditDate": "2026-02-15 08:12:28 +0100",
  "filesExamined": 3,
  "totalFindings": 13,
  "summary": {
    "critical": 0,
    "high": 6,
    "medium": 5,
    "low": 2
  },
  "findings": [
    {
      "severity": "HIGH",
      "number": 1,
      "title": "Authorization check collapses “not authorized” and “MusicKit/init is broken” into the same UI state",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "140-146",
      "category": "will-break",
      "description": "`isMusicKitAuthorized()` catches *all* exceptions from `initMusicKit()` and returns `false`. In `CreatePlaylistView`, `false` is interpreted as “user needs to connect Apple Music”, which means non-auth failures (missing `NEXT_PUBLIC_APPLE_MUSIC_APP_ID`, dev token API failure, MusicKit script not loaded) can incorrectly surface as an auth prompt instead of a real error.\n\nThis can strand users in a misleading “Connect Apple Music” loop when the actual problem is configuration or runtime initialization, not authorization.",
      "code": "export async function isMusicKitAuthorized(): Promise<boolean> {\n  try {\n    const music = await initMusicKit();\n    return music.isAuthorized === true;\n  } catch {\n    return false;\n  }\n}",
      "whyThisMatters": "Users can’t distinguish “please sign in” from “app is misconfigured / token endpoint is failing / script didn’t load,” making playlist export appear broken with no actionable diagnosis."
    },
    {
      "severity": "HIGH",
      "number": 2,
      "title": "“Needs auth” path is triggered by `isMusicKitAuthorized()` and hides init/config errors from the user",
      "file": "apps/web/src/features/playlist-export/CreatePlaylistView.tsx",
      "lines": "43-48, 162-169",
      "category": "will-break",
      "description": "When `isMusicKitAuthorized()` returns `false` (including due to swallowed init errors), the UI sets `needsAuth` and shows only the `ConnectAppleMusic` prompt. There is no separate error state for “MusicKit initialization failed” in this branch, so critical failures can be mislabeled as authorization problems.",
      "code": "const authorized = await isMusicKitAuthorized();\nif (!authorized) {\n  setNeedsAuth(true);\n  setLoading(false);\n  return;\n}",
      "whyThisMatters": "If the underlying failure is missing app ID / dev token fetch failure / MusicKit script load failure, “Connect Apple Music” is not a reliable recovery path and may never succeed."
    },
    {
      "severity": "HIGH",
      "number": 3,
      "title": "“Playlist created but add-tracks failed” view has no auth-revocation recovery path (retry can be a dead-end)",
      "file": "apps/web/src/features/playlist-export/CreatePlaylistView.tsx",
      "lines": "73-86, 110-128",
      "category": "will-break",
      "description": "After a playlist is created, the retry flow (`handleAddRemainingTracks`) only retries `addTracksToLibraryPlaylist` and never sets `needsAuth` or otherwise offers a reconnect UI in the “created” state. If add-tracks fails due to authorization being revoked/expired between create and add, the user is stuck repeatedly retrying an operation that will continue to fail.",
      "code": "async function handleAddRemainingTracks() {\n  if (!created || songIds.length === 0) return;\n  setAddTracksError(null);\n  setLoading(true);\n  try {\n    await addTracksToLibraryPlaylist(created.id, songIds);\n    setAddTracksError(null);\n  } catch (err) {\n    setAddTracksError(err instanceof Error ? err.message : String(err ?? \"Adding tracks failed.\"));\n  } finally {\n    setLoading(false);\n  }\n}",
      "whyThisMatters": "The exact scenario called out in the story (“create succeeds / add-tracks fails” + “auth revocation handling”) can devolve into an unrecoverable UX state."
    },
    {
      "severity": "HIGH",
      "number": 4,
      "title": "`addTracksToLibraryPlaylist` can throw “failure” after successfully adding tracks (invalid IDs are treated as an error post-write)",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "246-274",
      "category": "broken-logic",
      "description": "The function filters invalid IDs out before the POST (so valid tracks may be added), but if any IDs were dropped it throws an Error *after* the API call completes. This reports the operation as failed even when tracks were successfully added.\n\nBecause the UI uses thrown errors to show “adding tracks failed” and offers a retry button, this behavior can lead to repeated POSTs for already-added tracks (and potential duplication, depending on Apple Music playlist behavior).",
      "code": "const validIds = songIds.filter((id) => typeof id === \"string\" && id.trim().length > 0);\n// ...\nawait music.music.api(path, { method: \"POST\", data });\n// ...\nif (validIds.length < songIds.length) {\n  const dropped = songIds.length - validIds.length;\n  throw new Error(\n    `${dropped} of ${songIds.length} IDs were invalid and skipped; ${validIds.length} tracks added.`\n  );\n}",
      "whyThisMatters": "The app can tell users “add-tracks failed” even when it partially/mostly succeeded, encouraging retries that can mutate the playlist further."
    },
    {
      "severity": "HIGH",
      "number": 5,
      "title": "Retry/duplicate behavior relies on an unverified “idempotent per track” assumption",
      "file": "apps/web/src/features/playlist-export/CreatePlaylistView.tsx",
      "lines": "73-86",
      "category": "will-break",
      "description": "A code comment asserts that re-sending all IDs is safe because “Apple Music API add is idempotent per track.” There is no enforcement in code (no dedupe, no server-side idempotency key, no read-back to confirm membership), and Apple Music playlists are generally capable of containing duplicates.\n\nEven if the API sometimes de-duplicates, the current implementation provides no guarantees; the audit requirement explicitly calls out “duplicate playlist on retry” and “duplicate playlist on retry/track retry” risk.",
      "code": "/** DCI-057: Retry sends all song IDs again; Apple Music API add is idempotent per track, so duplicates are not created. */\nasync function handleAddRemainingTracks() {\n  // ...\n  await addTracksToLibraryPlaylist(created.id, songIds);\n}",
      "whyThisMatters": "If duplicates are allowed, the retry button can create playlists with repeated tracks, silently corrupting the exported result."
    },
    {
      "severity": "HIGH",
      "number": 6,
      "title": "MusicKit configuration + token caching has no recovery if developer token expires/invalidates mid-session",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "43-70, 96-122",
      "category": "will-break",
      "description": "The developer token is cached in-memory (`cachedToken` + `tokenExpiresAt`), and the configured MusicKit instance is cached forever (`configuredInstance`). There is no mechanism to reconfigure MusicKit after the initial `configure()` call, and no logic to clear caches/re-init on auth-like failures from Apple endpoints.\n\nIf the dev token expires earlier than expected, is rejected, or becomes invalid mid-session, playlist creation and add-tracks can fail until a full page reload.",
      "code": "let cachedToken: string | null = null;\nlet tokenExpiresAt = 0;\n// ...\nlet configuredInstance: MusicKitInstance | null = null;\n\nexport async function initMusicKit(): Promise<MusicKitInstance> {\n  if (configuredInstance) return configuredInstance;\n  const token = await fetchDeveloperToken();\n  const MusicKit = await waitForMusicKit();\n  MusicKit.configure({ developerToken: token, /* ... */ });\n  configuredInstance = MusicKit.getInstance();\n  return configuredInstance;\n}",
      "whyThisMatters": "Long-lived sessions can “randomly” break playlist export flows (create/add) with no in-app recovery besides reload."
    },
    {
      "severity": "MEDIUM",
      "number": 7,
      "title": "`createLibraryPlaylist` request shape/type appears inconsistent with Apple’s documented request object and library playlist types",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "218-225",
      "category": "will-break",
      "description": "`createLibraryPlaylist` sends a JSON:API-style payload with a `data` array and `type: \"playlists\"`. Apple’s documented creation request object for library playlists is `LibraryPlaylistCreationRequest`, which describes top-level `attributes` (required) and optional `relationships` (not a JSON:API `data` wrapper). Additionally, library playlists are commonly identified as `type: \"library-playlists\"` in responses.\n\nThis mismatch can cause request failures (400s) or subtle incompatibilities, and in the worst case could contribute to “retry creates duplicates” if creation succeeds server-side but the client fails to parse/accept the response.",
      "code": "const body = {\n  data: [{ type: \"playlists\" as const, attributes: { name } }],\n};\nconst res = (await music.music.api(path, {\n  method: \"POST\",\n  data: body,\n})) as { /* ... */ };",
      "whyThisMatters": "If the request payload doesn’t match the API contract, playlist export fails at the first step (playlist creation)."
    },
    {
      "severity": "MEDIUM",
      "number": 8,
      "title": "Playlist URL is likely unavailable/incorrectly sourced for library playlists, so the “Open in Apple Music” link may rarely appear",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "226-236",
      "category": "will-break",
      "description": "The code expects `playlist.attributes?.url` from the create response. Library playlist objects commonly include `playParams` and do not reliably include a direct `url` attribute. If `url` is usually absent, `CreatePlaylistView` will almost always fall back to “Open the Apple Music app and check your library…”, even on successful creation.",
      "code": "data?: Array<{ id: string; attributes?: { url?: string } }>;\n// ...\nreturn { id: playlist.id, url: playlist.attributes?.url };",
      "whyThisMatters": "This degrades the post-create UX: users can’t easily verify the playlist or open it directly from the app, even when everything succeeded."
    },
    {
      "severity": "MEDIUM",
      "number": 9,
      "title": "`addTracksToLibraryPlaylist` accepts `undefined` response and treats it as success unless `errors` exists",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "262-268",
      "category": "will-break",
      "description": "The function’s local typing explicitly allows `res` to be `undefined`, and the code only checks `res.errors`. If the MusicKit API wrapper returns `undefined` (or a non-object) on some failure mode without throwing, this code will treat the operation as successful and the UI will report no error.",
      "code": "const res = (await music.music.api(path, { method: \"POST\", data })) as\n  | { data?: unknown[]; errors?: Array<{ detail?: string; status?: string }> }\n  | undefined;\n\nif (res?.errors && Array.isArray(res.errors) && res.errors.length > 0) {\n  throw new Error(`Adding tracks to playlist failed: ${detail}`);\n}",
      "whyThisMatters": "Silent add-tracks failures produce “Playlist created” success UI while the playlist is missing tracks."
    },
    {
      "severity": "MEDIUM",
      "number": 10,
      "title": "Duplicate track IDs are not deduplicated before add-tracks; duplicates can be sent and added",
      "file": "apps/web/src/features/playlist-export/CreatePlaylistView.tsx",
      "lines": "35-36, 58-64, 73-86",
      "category": "will-break",
      "description": "`songIds` is a simple map/filter over match rows and is passed directly to add-tracks. If matching can produce duplicate Apple track IDs (e.g., repeated songs in setlist, user selects same track for multiple entries), duplicates are sent in the POST body. There is no dedupe step in UI or in `addTracksToLibraryPlaylist`.",
      "code": "const songIds = matchRows.map((r) => r.appleTrack?.id).filter(Boolean) as string[];\n// ...\nawait addTracksToLibraryPlaylist(id, songIds);",
      "whyThisMatters": "The resulting playlist can contain repeated tracks that don’t match user expectations, and retries amplify this risk."
    },
    {
      "severity": "MEDIUM",
      "number": 11,
      "title": "“Create playlist” button enablement uses `count`, but runtime empty-check uses `songIds.length`",
      "file": "apps/web/src/features/playlist-export/CreatePlaylistView.tsx",
      "lines": "35-36, 50-54, 153-160, 175",
      "category": "will-break",
      "description": "The UI disables the create button based on `count` (`appleTrack !== null`) but the actual no-tracks guard uses `songIds.length === 0` (truthy IDs only). If an `appleTrack` object exists but has a falsy/empty `id`, the UI can say it’s ready to create a playlist with N tracks and enable the button, but clicking “Create playlist” immediately errors with “No tracks to add…”.",
      "code": "const songIds = matchRows.map((r) => r.appleTrack?.id).filter(Boolean) as string[];\n\nif (songIds.length === 0) {\n  setError(\"No tracks to add. Match at least one track first.\");\n  // ...\n}\n\nconst count = matchRows.filter((m) => m.appleTrack !== null).length;\n// ...\ndisabled={loading || count === 0}",
      "whyThisMatters": "This creates confusing UX and can mask upstream data integrity problems in the matching output."
    },
    {
      "severity": "LOW",
      "number": 12,
      "title": "Minor export-flow slop: unused imports and redundant state updates",
      "file": "apps/web/src/features/playlist-export/CreatePlaylistView.tsx",
      "lines": "6-12, 44-47, 50-53",
      "category": "slop",
      "description": "- `authorizeMusicKit` and `initMusicKit` are imported but never used.\n- In early-return branches inside `try`, `setLoading(false)` is called before `return`, but `finally` also calls `setLoading(false)`, producing redundant state updates.",
      "code": "import {\n  isMusicKitAuthorized,\n  authorizeMusicKit,\n  initMusicKit,\n  createLibraryPlaylist,\n  addTracksToLibraryPlaylist,\n} from \"@/lib/musickit\";",
      "whyThisMatters": "This can fail lint/CI in stricter configurations and adds unnecessary re-render churn."
    },
    {
      "severity": "LOW",
      "number": 13,
      "title": "Minor reliability/UX gaps: waitForMusicKit timer cleanup and overly strict URL scheme check",
      "file": "apps/web/src/lib/musickit.ts",
      "lines": "72-93",
      "category": "will-break",
      "description": "- `waitForMusicKit` starts a `setTimeout` but doesn’t store/clear it on success; the callback still runs later (wasted work and potential confusion during debugging).\n- In the “playlist created” UI, only `http(s)` URLs are considered safe. If Apple returns a valid non-HTTP deep link scheme, the UI will suppress the link and fall back to manual instructions.",
      "code": "setTimeout(() => {\n  clearInterval(check);\n  reject(new Error(\"MusicKit script did not load\"));\n}, 10000);",
      "whyThisMatters": "These don’t usually break the flow, but they add friction in edge cases (slow script load, unusual URL formats)."
    }
  ],
  "auditId": "07-playlist-export",
  "sourceFile": "07-playlist-export.md"
}