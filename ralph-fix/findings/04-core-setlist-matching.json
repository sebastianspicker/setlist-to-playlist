{
  "auditTitle": "Core Package – Setlist & Matching",
  "auditDate": "2026-02-14T00:00:00Z",
  "filesExamined": 8,
  "totalFindings": 13,
  "summary": {
    "critical": 0,
    "high": 4,
    "medium": 5,
    "low": 4
  },
  "findings": [
    {
      "severity": "HIGH",
      "number": 1,
      "title": "`mapSetlistFmToSetlist` only reads `raw.set` and silently drops set data when the API returns a `sets` wrapper",
      "file": "packages/core/src/setlist/mapper.ts",
      "lines": "20-35",
      "category": "will-break",
      "description": "The mapper only attempts to read sets via `raw.set` and treats anything else as “no sets”. setlist.fm’s published JSON model documents a top-level `set` array, but the setlist.fm API forum documents a known discrepancy where responses can include a `sets` object containing the `set` array. In that scenario, this mapper returns `sets: []` without error, making imports appear successful while yielding zero tracks.",
      "code": "const sets: SetlistEntry[][] = [];\nconst fmSets = Array.isArray(raw.set) ? raw.set : [];\n\nfor (const fmSet of fmSets) {\n  if (!fmSet || typeof fmSet !== \"object\") continue;\n  const songs = Array.isArray(fmSet.song) ? fmSet.song : [];\n  // ...\n}",
      "whyThisMatters": "A setlist import can “succeed” but produce an empty tracklist, breaking the core flow (preview/matching/export) and making debugging difficult because no error is surfaced."
    },
    {
      "severity": "HIGH",
      "number": 2,
      "title": "Mapper “validates” `raw.artist` is an object but does not validate `artist.name` (or other fields) are strings, allowing invalid domain data",
      "file": "packages/core/src/setlist/mapper.ts",
      "lines": "10-19",
      "category": "will-break",
      "description": "The function checks `raw` and `raw.artist` are objects, but never validates `raw.artist.name` is a string. Because call sites can cast unknown JSON into `SetlistFmResponse`, runtime values can violate the TypeScript interfaces. If `raw.artist.name` is missing, empty, or a non-string, the function returns a `Setlist` with an empty or non-string `artist`, which then propagates into UI labels and Apple Music search queries.",
      "code": "if (!raw || typeof raw !== \"object\") {\n  throw new Error(\"Invalid setlist response\");\n}\nif (!raw.artist || typeof raw.artist !== \"object\") {\n  throw new Error(\"Invalid setlist response: missing artist\");\n}\nconst artistName = raw.artist?.name ?? \"\";",
      "whyThisMatters": "Downstream code assumes `setlist.artist` is meaningful. Invalid/empty artist names can degrade matching quality and can present confusing UX (“Setlist: ”)."
    },
    {
      "severity": "HIGH",
      "number": 3,
      "title": "Song filtering/type-guard is too weak; `SetlistEntry.name` can become non-string and empty-string entries are preserved",
      "file": "packages/core/src/setlist/mapper.ts",
      "lines": "25-33",
      "category": "broken-logic",
      "description": "The filter only checks that the song value is an object and that `\"name\" in s`, but does not validate that `s.name` is a string. As a result:\n- If `name` exists but is non-string (number/object), it passes the filter and is assigned to `SetlistEntry.name` via `s.name ?? \"\"` (non-nullish non-string values survive).\n- If `name` is missing/undefined, the code coerces it to `\"\"` and still includes the entry.",
      "code": "const entries: SetlistEntry[] = songs\n  .filter((s): s is SetlistFmSong => s != null && typeof s === \"object\" && \"name\" in s)\n  .map((s) => ({\n    name: s.name ?? \"\",\n    artist: artistName || undefined,\n    info: s.info ?? undefined,\n  }));",
      "whyThisMatters": "Invalid track names can lead to bad rendering (“” track rows) and can generate overly broad Apple Music searches (including artist-only queries), producing incorrect suggested matches."
    },
    {
      "severity": "HIGH",
      "number": 4,
      "title": "`normalizeTrackName` “feat/ft” regexes are missing word boundaries, so they can match inside unrelated words and corrupt titles",
      "file": "packages/core/src/matching/normalize.ts",
      "lines": "8-14",
      "category": "broken-logic",
      "description": "The `feat`/`ft` regexes begin with `\\s*`, which can match zero characters, and do not require a word boundary before `feat`/`ft`. This allows matches starting inside other words (e.g., substrings like `...feat...` / `...ft...`), and then strips subsequent characters due to `[^-]+...`.",
      "code": ".replace(/\\s*feat\\.?\\s*[^-]+(?:-\\s*[^-]+)*/gi, \"\")\n.replace(/\\s*ft\\.?\\s*[^-]+(?:-\\s*[^-]+)*/gi, \"\")",
      "whyThisMatters": "Track normalization can mangle legitimate titles, producing poor search queries and significantly increasing the chance of wrong matches."
    },
    {
      "severity": "MEDIUM",
      "number": 5,
      "title": "`normalizeTrackName` comment and implementation disagree; the “match until next ' - '” behavior is not what the regex does",
      "file": "packages/core/src/matching/normalize.ts",
      "lines": "8-13",
      "category": "slop",
      "description": "The inline comment claims the `feat/ft` segment is matched “until next ` - ` or end”, but the regex actually stops at any literal hyphen (`-`) (not specifically ` - `), and does not treat en-dash/em-dash consistently during the `feat/ft` removal step (those are handled later by the whitespace/hyphen normalization). This makes the actual removal behavior sensitive to punctuation choices and can under/over-strip.",
      "code": "// ... match until next \" - \" or end\n.replace(/\\s*feat\\.?\\s*[^-]+(?:-\\s*[^-]+)*/gi, \"\")",
      "whyThisMatters": "Misleading comments make future changes risky, and inconsistent stripping leads to unstable search behavior across real-world title formats."
    },
    {
      "severity": "MEDIUM",
      "number": 6,
      "title": "Parenthetical stripping is unconditional and removes canonical title content (not only metadata)",
      "file": "packages/core/src/matching/normalize.ts",
      "lines": "10-10",
      "category": "broken-logic",
      "description": "The normalization removes all parenthetical segments anywhere in the string, not just trailing metadata like “(live)” or “(acoustic)”. Many legitimate titles contain parentheses as part of the official name; removing them changes the search term materially.",
      "code": ".replace(/\\s*\\([^)]*\\)\\s*/g, \" \") // (live), (acoustic), etc.",
      "whyThisMatters": "Over-stripping can reduce match accuracy or cause the “best” match to be the wrong song (especially when multiple songs share the remaining token(s))."
    },
    {
      "severity": "MEDIUM",
      "number": 7,
      "title": "`buildSearchQuery` length cap is per-part, not total; combined query can exceed `MAX_QUERY_LENGTH` and the cap is a magic number",
      "file": "packages/core/src/matching/search-query.ts",
      "lines": "3-15",
      "category": "slop",
      "description": "`MAX_QUERY_LENGTH` is applied independently to track and artist, so the final query can be roughly `200 + 1 + 200` characters (plus normalization effects). If the intent is to prevent total query length from exceeding API limits, this does not enforce it. The constant is also a “magic number” without a referenced limit.",
      "code": "const MAX_QUERY_LENGTH = 200;\n\nconst track = normalizeTrackName(trackName).slice(0, MAX_QUERY_LENGTH);\nconst artist = (artistName?.trim() ?? \"\").slice(0, MAX_QUERY_LENGTH);\nconst parts = [track, artist].filter(Boolean);\nreturn parts.join(\" \").replace(/\\s+/g, \" \").trim();",
      "whyThisMatters": "Long inputs can still produce long queries and trigger upstream request failures or truncation behavior that is hard to reason about."
    },
    {
      "severity": "MEDIUM",
      "number": 8,
      "title": "`buildSearchQuery` can return artist-only queries, enabling “random” auto-suggestions when track normalizes to empty",
      "file": "packages/core/src/matching/search-query.ts",
      "lines": "10-14",
      "category": "will-break",
      "description": "When `normalizeTrackName(trackName)` returns `\"\"` (e.g., empty track name, or a name that is fully stripped), `buildSearchQuery` returns only the artist name. In the matching flow, an artist-only catalog search can return arbitrary popular tracks by that artist, and the first result can be incorrectly suggested as the match.",
      "code": "const parts = [track, artist].filter(Boolean);\nreturn parts.join(\" \").replace(/\\s+/g, \" \").trim();",
      "whyThisMatters": "Incorrect default matches create bad playlists unless the user manually audits every row, undermining trust in the “suggestions” step."
    },
    {
      "severity": "MEDIUM",
      "number": 9,
      "title": "`setlistfm-types` is incomplete and can be out-of-sync with both the docs and reported real responses (missing `lastUpdated`, missing `sets` wrapper, `cover/with` are `unknown`)",
      "file": "packages/core/src/setlist/setlistfm-types.ts",
      "lines": "1-44",
      "category": "will-break",
      "description": "Problems in the setlist.fm type modeling:\n- `SetlistFmResponse` omits documented fields like `lastUpdated`, increasing the odds that consumers cast/ignore fields and drift from reality.\n- The types only represent a top-level `set?: SetlistFmSet[]`, but the setlist.fm forum reports a known discrepancy where responses can include `sets: { set: [...] }`.\n- `SetlistFmSong.cover` and `SetlistFmSong.with` are typed as `unknown`, even though the docs model them as structured artist-like objects. This reduces type safety and discourages proper runtime checks.",
      "code": "export interface SetlistFmSong {\n  name: string;\n  info?: string;\n  cover?: unknown;\n  with?: unknown;\n  tape?: boolean;\n}\n\nexport interface SetlistFmResponse {\n  id: string;\n  versionId?: string;\n  eventDate: string;\n  artist: SetlistFmArtist;\n  venue?: SetlistFmVenue;\n  tour?: { name?: string };\n  set?: SetlistFmSet[];\n  info?: string;\n  url?: string;\n}",
      "whyThisMatters": "Type drift increases the chance that production data doesn’t match compile-time assumptions, leading to silent data loss (missing sets) or runtime oddities when values don’t conform."
    },
    {
      "severity": "LOW",
      "number": 10,
      "title": "`normalizeTrackName` docstring claims “extra punctuation” stripping, but implementation mostly preserves punctuation (except hyphens/dashes)",
      "file": "packages/core/src/matching/normalize.ts",
      "lines": "1-16",
      "category": "slop",
      "description": "The comment claims punctuation is stripped, but the implementation does not remove most punctuation characters (e.g., `!`, `.`, `,`, `'`, `:`). The only “punctuation-ish” normalization is collapsing hyphen/dash characters into spaces.",
      "code": "/**\n * Normalize track name for search: strip \"feat.\", \"live\", extra punctuation, parentheticals.\n */\n  // ...\n  .replace(/[\\s\\-–—]+/g, \" \")",
      "whyThisMatters": "Comments are used as “intent”; when they diverge from behavior, callers may overestimate normalization strength and rely on it for cases it does not handle."
    },
    {
      "severity": "LOW",
      "number": 11,
      "title": "`Setlist.eventDate` comment is ambiguous (“ISO or display”), but imported data is a fixed `dd-MM-yyyy` string per setlist.fm docs",
      "file": "packages/core/src/setlist/types.ts",
      "lines": "17-18",
      "category": "slop",
      "description": "The type comment suggests `eventDate` could be ISO, but the mapped setlist.fm field is documented as `dd-MM-yyyy`. This can cause downstream assumptions (sorting, formatting, parsing) to be wrong or inconsistent if a caller treats it as ISO.",
      "code": "/** Event date (ISO or display) */\neventDate?: string;",
      "whyThisMatters": "Date strings that look structured but aren’t ISO frequently lead to subtle bugs (lexicographic sorts, locale parsing differences, invalid `Date` parsing in JS)."
    },
    {
      "severity": "LOW",
      "number": 12,
      "title": "`AppleTrack` / `MatchResult` types are exported but unused anywhere in the repo (dead-end surface area)",
      "file": "packages/core/src/matching/types.ts",
      "lines": "1-12",
      "category": "dead-end",
      "description": "`AppleTrack` and `MatchResult` are defined and re-exported, but there are no imports/usages in the repository. This is a maintenance burden and can mislead readers into thinking there is core matching logic that produces/consumes `MatchResult` objects when there is not.",
      "code": "export interface AppleTrack { /* ... */ }\nexport interface MatchResult { /* ... */ }",
      "whyThisMatters": "Unused exported types expand the public API of `@repo/core` without corresponding implementation or adoption, increasing the cost of future refactors."
    },
    {
      "severity": "LOW",
      "number": 13,
      "title": "`SetlistFmArtist` / `SetlistFmVenue` / `SetlistFmSong` / `SetlistFmSet` are re-exported but unused in the repo",
      "file": "packages/core/src/setlist/index.ts",
      "lines": "2-8",
      "category": "dead-end",
      "description": "The setlist package index re-exports multiple setlist.fm API types, but repo usage appears to only depend on `SetlistFmResponse`. This creates additional public surface area and implies stability/accuracy requirements for types that are not actively consumed or validated.",
      "code": "export type {\n  SetlistFmResponse,\n  SetlistFmArtist,\n  SetlistFmVenue,\n  SetlistFmSong,\n  SetlistFmSet,\n} from \"./setlistfm-types.js\";",
      "whyThisMatters": "Exporting more API-facing types than needed increases the blast radius of type drift (especially given the known doc/response discrepancies for sets)."
    }
  ],
  "auditId": "04-core-setlist-matching",
  "sourceFile": "04-core-setlist-matching.md"
}