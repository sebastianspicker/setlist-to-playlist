# Fix Report: FIX-011 — Fix 11-types findings

**Date:** 2026-02-15T12:27:06Z
**Verification:** pnpm lint + pnpm test passed

---

## Findings addressed

### [CRITICAL] Finding #1: `SetlistFmResponse` models `set` but real responses use `sets: { set: ... }` (songs can be dropped)

**File:** `packages/core/src/setlist/setlistfm-types.ts`

**Lines:** 34-44

**Description:** `SetlistFmResponse` defines `set?: SetlistFmSet[]`, implying the set array is at the top level. Multiple real-world examples show setlist.fm responses using a wrapper object `sets` containing `set` (array). With the current type, downstream code is encouraged to read `raw.set`, and valid responses shaped as `raw.sets.set` will appear as “no sets”.

**Fix applied:** Addressed (verification passed).

---

### [CRITICAL] Finding #2: Mapper only reads `raw.set`, so `raw.sets.set` responses map to empty `sets`

**File:** `packages/core/src/setlist/mapper.ts`

**Lines:** 20-35

**Description:** The mapper uses `Array.isArray(raw.set)` and otherwise treats the setlist as having no sets. If the incoming payload uses `sets: { set: [...] }`, this produces an empty `Setlist.sets` and downstream UIs show zero tracks.

**Fix applied:** Addressed (verification passed).

---

### [HIGH] Finding #3: Web client casts proxy JSON to `SetlistFmResponse` without validating shape (type safety is illusory)

**File:** `apps/web/src/features/setlist-import/SetlistImportView.tsx`

**Lines:** 48-72

**Description:** The client parses JSON into `{ error?: string } | SetlistFmResponse`, and on success forcibly casts `data as SetlistFmResponse` and passes it to the mapper. The only “validation” is `!res.ok || "error" in data`, which does not assert required fields (`artist`, `eventDate`, and especially the `set` vs `sets` structure). This can convert a real API payload into a mapped setlist with empty tracks (or throw inside the mapper).

**Fix applied:** Addressed (verification passed).

---

### [HIGH] Finding #4: MusicKit JS surface is modeled ad-hoc (`music.music.api`) and conflicts with common/typed `api` surfaces (risk of runtime `undefined`)

**File:** `apps/web/src/lib/musickit.ts`

**Lines:** 27-35, 187-190, 222-228, 262-264

**Description:** The local `MusicKitInstance` interface defines a `music: { api: (path, options) => Promise<unknown> }`, and all Apple Music calls are made via `music.music.api(...)`. Widely used typings and references for MusicKit JS expose an `api` object on the instance (e.g. `music.api.music(...)`) rather than an extra `.music` nesting. If the real runtime instance does not match this hand-written shape, calls like `music.music.api` will throw (`Cannot read properties of undefined`).

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #5: `SetlistFmVenue.city` / `country` shape is truncated and has incorrect required fields vs observed payloads

**File:** `packages/core/src/setlist/setlistfm-types.ts`

**Lines:** 13-18

**Description:** `city` is modeled as `{ name: string; country?: { code: string } }`, but observed payloads commonly include `city.id`, `state`, `stateCode`, `coords`, and `country.name`, and may include empty objects for `country` in some cases. As written, if `country` is present but missing `code`, the type encourages unsafe access patterns.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #6: `SetlistFmSong.cover` / `with` typed as `unknown` despite being documented/observed as artist objects

**File:** `packages/core/src/setlist/setlistfm-types.ts`

**Lines:** 20-26

**Description:** `cover` and `with` are typed as `unknown`, losing a clear domain shape (artist-like objects). This pushes consumers toward unsafe casting or ignoring useful metadata.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #7: `SetlistFmResponse` omits `lastUpdated` and weakens `versionId` / `url` optionality compared to documented contracts

**File:** `packages/core/src/setlist/setlistfm-types.ts`

**Lines:** 34-44

**Description:** The type does not include `lastUpdated`, and marks `versionId` and `url` optional. Documentation indicates `lastUpdated` and `url` exist on the Setlist object; weakening these fields makes it easy to forget attribution (`url`) and obscures update/refresh logic (`lastUpdated`, `versionId`).

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #8: `SetlistFmSet.song` is required in the type, but mapper treats it as optional/malformed (type and runtime expectations disagree)

**File:** `packages/core/src/setlist/setlistfm-types.ts`

**Lines:** 28-32

**Description:** The type requires `song: SetlistFmSong[]`, but the mapper defensively does `Array.isArray(fmSet.song) ? fmSet.song : []`, implying `song` may be missing or non-array at runtime. This mismatch means the type contract does not reflect real-world variability or the app’s own defensive posture.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #9: Mapper’s type guard `s is SetlistFmSong` is unsound (only checks `"name" in s`)

**File:** `packages/core/src/setlist/mapper.ts`

**Lines:** 27-33

**Description:** The filter claims to narrow to `SetlistFmSong` but only asserts that `name` exists as a key, not that `name` is a string (or that other fields match). This undermines the value of the `SetlistFmSong` type within the mapper and can let unexpected values through as if they were valid songs.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #10: Proxy and fetcher return `unknown` bodies, forcing unsafe assertions across the API boundary

**File:** `apps/api/src/routes/setlist/proxy.ts`

**Lines:** 6-8

**Description:** Successful proxy responses carry `body: unknown`, and the proxy does not validate/normalize the upstream response into a known `SetlistFmResponse` shape before returning it.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #11: setlist.fm fetcher result type also uses `body: unknown`, reinforcing downstream casts

**File:** `apps/api/src/lib/setlistfm.ts`

**Lines:** 72-74, 96-100

**Description:** `FetchSetlistResult` uses `body: unknown` even on `ok: true`, and stores cached payloads as `unknown`. This spreads uncertainty downstream and makes it hard to prove that the mapper receives the expected setlist shape.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #12: `DevTokenResponse` is duplicated and weakened in the web client (union vs “all-optional” object)

**File:** `apps/api/src/routes/apple/dev-token.ts`

**Lines:** 3

**Description:** The API defines a strict union `{ token } | { error }`, but the client models the parsed JSON as `{ token?: string; error?: string }`, which permits impossible states (`{}` or `{ token, error }`) and loses the mutual exclusivity guarantee.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #13: MusicKit `configure()` return type is overly broad, forcing “thenable duck-typing”

**File:** `apps/web/src/lib/musickit.ts`

**Lines:** 9-12, 112-120

**Description:** `configure()` is typed as returning `Promise<MusicKitInstance> | MusicKitInstance | void`, and the implementation checks for `.then` at runtime. This suggests the code does not know the real contract and makes the integration more fragile.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #14: MusicKit API response typing is under-specified and can silently produce empty-string track names

**File:** `apps/web/src/lib/musickit.ts`

**Lines:** 187-200, 37-41

**Description:** The search response is cast with optional `attributes?.name`, and the mapping falls back to `""` when missing. Meanwhile, `AppleMusicTrack.name` is typed as required `string`, implying it’s always meaningful. This mismatch can silently create blank track labels and degrade matching/selection UX.

**Fix applied:** Addressed (verification passed).

---

### [MEDIUM] Finding #15: Apple track shapes are duplicated across core and web (risk of drift/inconsistent optionality)

**File:** `packages/core/src/matching/types.ts`

**Lines:** 1-5

**Description:** Core defines `AppleTrack`, while web defines `AppleMusicTrack` with a similar shape. These are parallel contracts that can drift (fields, optionality, meaning) without TypeScript catching mismatches across package boundaries.

**Fix applied:** Addressed (verification passed).

---

### [LOW] Finding #16: Placeholder type exported publicly but unused (`AppleCatalogTrack`)

**File:** `packages/core/src/apple/types.ts`

**Lines:** 1-8

**Description:** `AppleCatalogTrack` is explicitly labeled “Placeholder” and exported via `@repo/core` (through `packages/core/src/apple/index.ts`), but no usages exist in the repo. Its high optionality (`attributes?`, `name?`) also indicates it is not a stable contract.

**Fix applied:** Addressed (verification passed).

---

### [LOW] Finding #17: `Setlist.sets` is required by type but treated as optional in web usage (inconsistent contract assumptions)

**File:** `packages/core/src/setlist/types.ts`

**Lines:** 10-21

**Description:** `Setlist.sets` is required (`SetlistEntry[][]`), but web code frequently uses `setlist.sets ?? []` patterns, implying it may be missing/undefined. This inconsistency suggests the domain contract isn’t trusted by consumers.

**Fix applied:** Addressed (verification passed).

---


*Report generated by ralph-fix.sh after verification passed.*
